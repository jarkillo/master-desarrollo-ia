# Clase 5: Deploy en Cloud (Railway y Render)

**M√≥dulo 4 - Infraestructura y Cloud**

---

## üìã Tabla de Contenidos

1. [Objetivos de Aprendizaje](#objetivos-de-aprendizaje)
2. [Qu√© Aprendimos Antes](#qu√©-aprendimos-antes)
3. [Qu√© Vamos a Aprender Ahora](#qu√©-vamos-a-aprender-ahora)
4. [Arquitectura de la Aplicaci√≥n](#arquitectura-de-la-aplicaci√≥n)
5. [Deploy en Railway](#deploy-en-railway)
6. [Deploy en Render](#deploy-en-render)
7. [Environment Variables](#environment-variables)
8. [Troubleshooting con IA](#troubleshooting-con-ia)
9. [Testing](#testing)
10. [Recursos Adicionales](#recursos-adicionales)

---

## üéØ Objetivos de Aprendizaje

Al completar esta clase, ser√°s capaz de:

- ‚úÖ Preparar una aplicaci√≥n FastAPI para producci√≥n
- ‚úÖ Configurar environment variables para diferentes entornos (dev/prod)
- ‚úÖ Desplegar en Railway y Render
- ‚úÖ Conectar a PostgreSQL en cloud
- ‚úÖ Usar Docker en producci√≥n
- ‚úÖ Implementar health checks
- ‚úÖ **Usar IA para troubleshooting de deployment** (40% AI content)

---

## üìö Qu√© Aprendimos Antes

### Clase 1: Del c√≥digo local al entorno vivo
- Conceptos de deployment
- Diferencias local vs cloud

### Clase 2: Tu API en un contenedor
- Docker basics
- Dockerfile
- Contenedores

### Clase 3: Base de Datos con SQLAlchemy
- SQLAlchemy 2.0
- Modelos ORM
- Sesiones de BD

### Clase 4: Migraciones con Alembic
- Alembic migrations
- Versionado de schema
- Migraciones reversibles

---

## üöÄ Qu√© Vamos a Aprender Ahora

### 1. Configuraci√≥n Din√°mica (Pydantic Settings)

**Problema en Clase 4:**
```python
# ‚ùå Configuraci√≥n hardcodeada
DATABASE_URL = "sqlite:///./tareas.db"
```

**Soluci√≥n Clase 5:**
```python
# ‚úÖ Configuraci√≥n din√°mica con environment variables
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    database_url: str = "sqlite:///./tareas.db"
    environment: Literal["dev", "staging", "prod"] = "dev"

    model_config = SettingsConfigDict(env_file=".env")

settings = Settings()
```

**Ventajas:**
- Mismo c√≥digo para dev/staging/prod
- Configuraci√≥n via environment variables
- Validaci√≥n autom√°tica de tipos
- Valores por defecto seguros

---

### 2. Multi-Database Support (SQLite ‚Üí PostgreSQL)

**Desarrollo (SQLite):**
```python
DATABASE_URL=sqlite:///./tareas.db
```

**Producci√≥n (PostgreSQL):**
```python
DATABASE_URL=postgresql://user:pass@host:port/database
```

**C√≥digo adapta autom√°ticamente:**
```python
def get_engine_config():
    if settings.database_url.startswith("sqlite"):
        return {"poolclass": NullPool}  # SQLite
    else:
        return {
            "poolclass": QueuePool,  # PostgreSQL
            "pool_size": 5,
            "pool_pre_ping": True
        }
```

---

### 3. Health Checks para Cloud Platforms

**Railway y Render necesitan saber si tu app est√° viva:**

```python
@app.get("/health")
def health_check():
    """
    Health check completo: API + Base de datos.

    Retorna:
    - 200 OK: Todo funciona
    - 503 Service Unavailable: BD desconectada
    """
    db_health = check_database_health()

    if db_health["status"] == "error":
        return JSONResponse(
            status_code=503,
            content={"status": "unhealthy", "database": db_health}
        )

    return {"status": "healthy", "database": db_health}
```

---

### 4. CORS para Frontend Separado

Si tienes un frontend en otro dominio:

```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://tu-frontend.vercel.app"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

---

### 5. Logging en Producci√≥n

```python
import logging

logging.basicConfig(
    level=settings.log_level,  # INFO en prod, DEBUG en dev
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)

logger = logging.getLogger(__name__)

# En endpoints:
logger.info(f"Creando tarea: {tarea_data.nombre}")
logger.warning(f"Tarea {id} no encontrada")
logger.error(f"Error de base de datos: {str(e)}")
```

---

## üèóÔ∏è Arquitectura de la Aplicaci√≥n

```
Clase 5/
‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îú‚îÄ‚îÄ config.py           # ‚≠ê NUEVO: Pydantic Settings
‚îÇ   ‚îú‚îÄ‚îÄ database.py         # ‚≠ê ADAPTADO: Multi-DB support
‚îÇ   ‚îú‚îÄ‚îÄ api.py              # ‚≠ê MEJORADO: Health checks, CORS, logging
‚îÇ   ‚îú‚îÄ‚îÄ models.py           # (Sin cambios)
‚îÇ   ‚îú‚îÄ‚îÄ servicio_tareas.py  # (Sin cambios)
‚îÇ   ‚îú‚îÄ‚îÄ repositorio_db.py   # (Sin cambios)
‚îÇ   ‚îî‚îÄ‚îÄ dependencias.py     # (Sin cambios)
‚îÇ
‚îú‚îÄ‚îÄ infra/
‚îÇ   ‚îî‚îÄ‚îÄ .env.template       # Template de variables de entorno
‚îÇ
‚îú‚îÄ‚îÄ Dockerfile              # ‚≠ê Multi-stage build optimizado
‚îú‚îÄ‚îÄ railway.toml            # ‚≠ê Config para Railway
‚îú‚îÄ‚îÄ render.yaml             # ‚≠ê Infrastructure-as-Code para Render
‚îú‚îÄ‚îÄ requirements.txt        # + pydantic-settings, psycopg2
‚îÇ
‚îú‚îÄ‚îÄ AI_TROUBLESHOOTING.md   # ‚≠ê 40% AI content
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ GLOSARIO.md
```

---

## üöÇ Deploy en Railway

### Paso 1: Crear Cuenta en Railway

1. Ve a [railway.app](https://railway.app)
2. Sign up con GitHub
3. Verifica tu email

---

### Paso 2: Crear Nuevo Proyecto

1. Click en "New Project"
2. Selecciona "Deploy from GitHub repo"
3. Autoriza Railway a acceder a tu repositorio
4. Selecciona tu repo

---

### Paso 3: Agregar PostgreSQL

1. En tu proyecto, click "New Service"
2. Selecciona "Database" ‚Üí "PostgreSQL"
3. Railway crea autom√°ticamente la BD y expone `DATABASE_URL`

---

### Paso 4: Configurar Variables de Entorno

En el dashboard de Railway, ve a "Variables" y agrega:

```bash
ENVIRONMENT=prod
LOG_LEVEL=INFO
SECRET_KEY=tu-clave-secreta-generada-con-openssl-rand-hex-32
CORS_ORIGINS=["https://tu-frontend.com"]
```

**‚ö†Ô∏è Railway proporciona `DATABASE_URL` autom√°ticamente, NO la agregues manualmente.**

---

### Paso 5: Deploy Autom√°tico

Railway detecta autom√°ticamente:
- `Dockerfile` ‚Üí Usa Docker build
- `railway.toml` ‚Üí Lee configuraci√≥n

**railway.toml** (ya incluido):
```toml
[build]
builder = "dockerfile"

[deploy]
startCommand = "uvicorn api.api:app --host 0.0.0.0 --port $PORT --workers 2"
healthcheckPath = "/health"
restartPolicyType = "on_failure"
```

¬°Tu app se despliega autom√°ticamente! üéâ

---

### Paso 6: Ejecutar Migraciones (si usas Alembic)

Si tu app usa Alembic, necesitas ejecutar migrations manualmente la primera vez:

**Opci√≥n 1: Desde Railway CLI**
```bash
railway login
railway link
railway run alembic upgrade head
```

**Opci√≥n 2: En el startCommand**
```toml
startCommand = "alembic upgrade head && uvicorn api.api:app --host 0.0.0.0 --port $PORT"
```

---

### Paso 7: Verificar Deployment

1. Railway te da una URL: `https://tu-app.up.railway.app`
2. Ve a `https://tu-app.up.railway.app/health`
3. Deber√≠as ver:
   ```json
   {
     "status": "healthy",
     "api": "ok",
     "database": {"status": "ok"},
     "environment": "prod"
   }
   ```

---

## üé® Deploy en Render

### Paso 1: Crear Cuenta en Render

1. Ve a [render.com](https://render.com)
2. Sign up con GitHub
3. Verifica tu email

---

### Paso 2: Crear Blueprint (Infrastructure-as-Code)

Render usa `render.yaml` para definir TODA tu infraestructura:

**render.yaml** (ya incluido):
```yaml
services:
  # PostgreSQL Database
  - type: pserv
    name: tareas-db
    env: docker
    plan: free
    databaseName: tareas_db

  # Web Service
  - type: web
    name: tareas-api
    env: docker
    plan: free
    dockerfilePath: ./Dockerfile
    healthCheckPath: /health

    envVars:
      - key: ENVIRONMENT
        value: prod

      - key: DATABASE_URL
        fromDatabase:
          name: tareas-db
          property: connectionString

      - key: SECRET_KEY
        generateValue: true
```

---

### Paso 3: Deploy desde GitHub

1. En Render, click "New" ‚Üí "Blueprint"
2. Conecta tu repositorio de GitHub
3. Render detecta `render.yaml` autom√°ticamente
4. Click "Apply"

Render crea:
- PostgreSQL database
- Web service
- Conecta autom√°ticamente con `DATABASE_URL`

---

### Paso 4: Verificar Deployment

1. Render te da una URL: `https://tu-app.onrender.com`
2. Ve a `https://tu-app.onrender.com/health`

**‚ö†Ô∏è IMPORTANTE:** Render free tier pone tu app en sleep despu√©s de 15min de inactividad. La primera request puede tardar ~30s.

---

### Paso 5: Ejecutar Migraciones

**En render.yaml**, agrega un Build Command:

```yaml
buildCommand: "pip install -r requirements.txt && alembic upgrade head"
```

O crea un script:

**start.sh:**
```bash
#!/bin/bash
alembic upgrade head
uvicorn api.api:app --host 0.0.0.0 --port $PORT --workers 2
```

**render.yaml:**
```yaml
startCommand: "bash start.sh"
```

---

## üîê Environment Variables

### Development (.env local)

```bash
ENVIRONMENT=dev
DATABASE_URL=sqlite:///./tareas.db
LOG_LEVEL=DEBUG
CORS_ORIGINS=["*"]
SECRET_KEY=dev-secret-not-for-production
```

### Production (Railway/Render)

```bash
ENVIRONMENT=prod
DATABASE_URL=postgresql://user:pass@host/database  # Auto-provisto
LOG_LEVEL=INFO
CORS_ORIGINS=["https://tu-frontend.com"]
SECRET_KEY=<generar con openssl rand -hex 32>
```

### Generar SECRET_KEY Segura

```bash
openssl rand -hex 32
# Output: a1b2c3d4e5f6...
```

---

## ü§ñ Troubleshooting con IA (40% AI Content)

**Ver documento completo:** [`AI_TROUBLESHOOTING.md`](./AI_TROUBLESHOOTING.md)

### Errores Comunes y C√≥mo Pedir Ayuda a la IA

#### Error 1: "ModuleNotFoundError"

**Prompt efectivo:**
```
Mi FastAPI app funciona localmente pero en Railway obtengo:

  ModuleNotFoundError: No module named 'api.config'

Dockerfile:
  [pega tu Dockerfile]

Estructura de archivos:
  api/
    config.py
    api.py

¬øQu√© falta?
```

---

#### Error 2: Database Connection Refused

**Prompt efectivo:**
```
Deploy en Railway con PostgreSQL.

Error:
  sqlalchemy.exc.OperationalError: could not connect to server

Variables de entorno:
  DATABASE_URL = postgresql://...

database.py:
  [pega c√≥digo]

¬øQu√© reviso?
```

---

#### Error 3: Health Check Failed

**Prompt efectivo:**
```
Railway build exitoso pero health check falla.

Logs:
  ‚úÖ Building...
  ‚ùå Health check failed after 5 minutes

railway.toml:
  healthcheckPath = "/health"

api.py:
  @app.get("/health")
  def health():
      check_database_health()  # Tarda >30s

¬øPor qu√© falla?
```

**Soluci√≥n (IA te dir√°):** Health checks deben ser ultra-r√°pidos (<5s). Mueve queries pesadas a `/health/full`.

---

### Template de Prompt para Troubleshooting

```markdown
# CONTEXTO
- Plataforma: Railway / Render
- Tecnolog√≠a: FastAPI + SQLAlchemy + PostgreSQL
- Database: PostgreSQL 15

# PROBLEMA
[Descripci√≥n del error]

# ERROR EXACTO
```
[Stack trace completo]
```

# C√ìDIGO RELEVANTE
```python
[Pega c√≥digo: api.py, database.py, Dockerfile]
```

# CONFIGURACI√ìN
- Variables de entorno: [Lista]
- railway.toml / render.yaml: [Pega config]

# QU√â INTENT√â
1. [Acci√≥n 1]
2. [Acci√≥n 2]

# PREGUNTA
¬ø[Tu pregunta espec√≠fica]?
```

---

## üß™ Testing

### Ejecutar Tests Localmente

```bash
# Activar entorno virtual
.venv\Scripts\activate  # Windows
source .venv/bin/activate  # Linux/Mac

# Tests unitarios
pytest tests/ -v

# Tests de integraci√≥n
pytest tests_integrations/ -v

# Todos los tests con coverage
pytest --cov=api --cov-report=term-missing --cov-fail-under=80
```

---

### Tests Espec√≠ficos de Clase 5

```python
# test_api_clase5.py

def test_root_endpoint(client):
    """Health check b√°sico"""
    response = client.get("/")
    assert response.status_code == 200
    assert response.json()["status"] == "ok"

def test_health_check_endpoint(client):
    """Health check completo (API + BD)"""
    response = client.get("/health")
    assert response.status_code == 200
    assert response.json()["status"] == "healthy"
    assert response.json()["database"]["status"] == "ok"

def test_cors_headers_present(client):
    """CORS headers configurados"""
    response = client.get("/tareas", headers={"Origin": "https://example.com"})
    assert "access-control-allow-origin" in response.headers
```

---

## üì¶ Docker Local Testing

Antes de deployar, prueba localmente con Docker:

```bash
# Build image
docker build -t tareas-api-clase5 .

# Run container
docker run -p 8000:8000 -e ENVIRONMENT=dev tareas-api-clase5

# Test
curl http://localhost:8000/health
```

---

## üîß Comparaci√≥n: Railway vs Render

| Feature | Railway | Render |
|---------|---------|--------|
| **Free tier** | $5 cr√©dito/mes | Free con limitaciones |
| **Sleep** | No | S√≠ (15min inactividad) |
| **PostgreSQL** | S√≠ (incluido) | S√≠ (incluido) |
| **Config** | railway.toml | render.yaml (IaC) |
| **CLI** | Excelente | Limitado |
| **Logs** | Tiempo real | Tiempo real |
| **Deployment** | Push to GitHub | Push to GitHub |
| **Custom domains** | S√≠ | S√≠ |
| **Environment vars** | Dashboard + CLI | Dashboard + render.yaml |

**Recomendaci√≥n:**
- **Railway**: Mejor DX, no sleep, excelente CLI
- **Render**: M√°s generous free tier, IaC completo

---

## üìö Recursos Adicionales

### Documentaci√≥n Oficial

- [Railway Docs](https://docs.railway.app/)
- [Render Docs](https://render.com/docs)
- [FastAPI Deployment](https://fastapi.tiangolo.com/deployment/)
- [Pydantic Settings](https://docs.pydantic.dev/latest/concepts/pydantic_settings/)

### Troubleshooting con IA

- [AI_TROUBLESHOOTING.md](./AI_TROUBLESHOOTING.md) - Gu√≠a completa (40% AI content)
- [Claude Code](https://claude.ai/code) - AI assistant para debugging
- [GitHub Copilot](https://github.com/features/copilot) - Sugerencias inline

### Seguridad

- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [Security Best Practices](https://cheatsheetseries.owasp.org/)

---

## üéì Ejercicios Propuestos

### Ejercicio 1: Deploy Completo

1. Despliega la app en Railway
2. Conecta PostgreSQL
3. Configura environment variables
4. Ejecuta migrations
5. Verifica health checks
6. Consume la API desde Postman/curl

### Ejercicio 2: Troubleshoot con IA

1. Introduce un error intencional (ej: quita `DATABASE_URL`)
2. Deploy y observa el error
3. Usa Claude/ChatGPT para diagnosticar
4. Documenta el proceso en tu "Playbook de Errores"

### Ejercicio 3: Frontend + Backend

1. Crea un simple frontend (HTML/JS o React)
2. Despliega frontend en Vercel/Netlify
3. Configura CORS correctamente
4. Consume tu API desplegada en Railway

---

## ‚úÖ Checklist de Deployment

Antes de considerar el deployment completo, verifica:

- [ ] App funciona localmente con Docker
- [ ] Tests pasan (pytest con coverage >80%)
- [ ] Health checks funcionan (`/` y `/health`)
- [ ] Environment variables configuradas
- [ ] PostgreSQL conectado
- [ ] Migrations ejecutadas
- [ ] CORS configurado si tienes frontend
- [ ] Logs no exponen secrets
- [ ] SECRET_KEY es fuerte (no "change-me")
- [ ] API responde en la URL p√∫blica
- [ ] Documentaci√≥n API accesible (si no es prod)

---

## üéØ Conclusi√≥n

**Has aprendido:**

‚úÖ Configuraci√≥n din√°mica con Pydantic Settings
‚úÖ Multi-database support (SQLite ‚Üí PostgreSQL)
‚úÖ Docker multi-stage builds optimizados
‚úÖ Health checks para cloud platforms
‚úÖ CORS para frontends separados
‚úÖ Logging apropiado para producci√≥n
‚úÖ Deploy en Railway y Render
‚úÖ **Troubleshooting con IA (40% AI content)**

**Pr√≥xima clase:**
- **Clase 6**: CI/CD con GitHub Actions
- **Clase 7**: Monitoring y Observabilidad con Sentry
- **Clase 8**: Escalabilidad y Performance

---

**¬øDudas? ¬øErrores? ¬°Usa IA para troubleshooting!** Revisa [`AI_TROUBLESHOOTING.md`](./AI_TROUBLESHOOTING.md) para aprender c√≥mo.
