"""
Ejercicio 4: Subagentes y paralelizaci√≥n

Objetivo:
Crear un agente principal que coordina subagentes especializados,
demostrando paralelizaci√≥n y gesti√≥n de contexto compartimentado.

Conceptos:
- Arquitectura de subagentes
- Paralelizaci√≥n de tareas
- Context management compartimentado
- Agregaci√≥n de resultados

Caso de uso:
Agente principal que analiza un proyecto completo delegando tareas
a subagentes especializados:
- SearchAgent: Busca en documentaci√≥n y c√≥digo
- AnalysisAgent: Analiza calidad y arquitectura
- TestAgent: Ejecuta y valida tests
"""

import asyncio
import os
from concurrent.futures import ThreadPoolExecutor, as_completed
from dataclasses import dataclass
from datetime import datetime
from typing import Any
from anthropic import Anthropic


@dataclass
class SubagentResult:
    """Resultado de ejecuci√≥n de un subagente."""

    agent_name: str
    success: bool
    output: str
    error: str | None = None
    execution_time: float = 0.0
    metadata: dict[str, Any] | None = None


class BaseSubagent:
    """
    Clase base para todos los subagentes.

    Los subagentes son contextos de ejecuci√≥n aislados que:
    - Operan independientemente
    - Retornan solo informaci√≥n relevante (no todo el contexto)
    - Pueden ejecutarse en paralelo
    """

    def __init__(self, name: str, api_key: str | None = None):
        self.name = name
        self.client = Anthropic(api_key=api_key or os.getenv("ANTHROPIC_API_KEY"))
        self.model = "claude-3-5-sonnet-20241022"

    def execute(self, task: str) -> SubagentResult:
        """
        Ejecuta la tarea asignada al subagente.

        Args:
            task: Tarea espec√≠fica para este subagente

        Returns:
            SubagentResult con el resultado
        """
        start_time = datetime.now()

        try:
            # Llamar a Claude con contexto espec√≠fico del subagente
            response = self.client.messages.create(
                model=self.model,
                max_tokens=2048,
                system=self._get_system_prompt(),
                messages=[{"role": "user", "content": task}],
            )

            execution_time = (datetime.now() - start_time).total_seconds()

            return SubagentResult(
                agent_name=self.name,
                success=True,
                output=response.content[0].text,
                execution_time=execution_time,
                metadata={"tokens_used": response.usage.input_tokens + response.usage.output_tokens},
            )

        except Exception as e:
            execution_time = (datetime.now() - start_time).total_seconds()
            return SubagentResult(
                agent_name=self.name,
                success=False,
                output="",
                error=str(e),
                execution_time=execution_time,
            )

    def _get_system_prompt(self) -> str:
        """
        System prompt espec√≠fico del subagente.

        Override en subclases para especializaci√≥n.
        """
        return "Eres un asistente √∫til."


class SearchAgent(BaseSubagent):
    """Subagente especializado en b√∫squeda de informaci√≥n."""

    def __init__(self, api_key: str | None = None):
        super().__init__("SearchAgent", api_key)

    def _get_system_prompt(self) -> str:
        return """Eres un agente de b√∫squeda especializado.

Tu trabajo:
- Buscar informaci√≥n relevante en c√≥digo, docs, y archivos
- Proporcionar SOLO excerpts relevantes, no archivos completos
- Usar comandos bash eficientemente (grep, find, cat con head/tail)
- Ser preciso y conciso

Formato de respuesta:
1. Qu√© encontraste
2. D√≥nde lo encontraste (archivo:l√≠nea)
3. Contexto relevante (3-5 l√≠neas alrededor)

NO devuelvas archivos completos. Solo informaci√≥n relevante."""


class AnalysisAgent(BaseSubagent):
    """Subagente especializado en an√°lisis de c√≥digo."""

    def __init__(self, api_key: str | None = None):
        super().__init__("AnalysisAgent", api_key)

    def _get_system_prompt(self) -> str:
        return """Eres un agente de an√°lisis de c√≥digo especializado.

Tu trabajo:
- Analizar calidad de c√≥digo (SOLID, clean code, etc.)
- Detectar code smells y anti-patterns
- Sugerir mejoras arquitect√≥nicas
- Evaluar test coverage conceptualmente

Formato de respuesta:
1. Resumen ejecutivo (2-3 l√≠neas)
2. Aspectos positivos
3. √Åreas de mejora (priorizado)
4. Recomendaciones espec√≠ficas

S√© constructivo pero directo. Enf√≥cate en lo m√°s importante."""


class TestAgent(BaseSubagent):
    """Subagente especializado en testing."""

    def __init__(self, api_key: str | None = None):
        super().__init__("TestAgent", api_key)

    def _get_system_prompt(self) -> str:
        return """Eres un agente de testing especializado.

Tu trabajo:
- Validar existencia y calidad de tests
- Identificar gaps en test coverage
- Sugerir tests adicionales
- Evaluar estrategia de testing (unit, integration, e2e)

Formato de respuesta:
1. Estado actual de tests
2. Coverage (estimado conceptualmente)
3. Gaps identificados
4. Tests recomendados (priorizado)

Enf√≥cate en calidad, no cantidad. Tests valiosos sobre tests innecesarios."""


class MasterAgent:
    """
    Agente principal que coordina subagentes especializados.

    Implementa:
    - Delegaci√≥n de tareas a subagentes
    - Ejecuci√≥n paralela (ThreadPoolExecutor)
    - Agregaci√≥n de resultados
    - S√≠ntesis final
    """

    def __init__(self, api_key: str | None = None):
        self.api_key = api_key or os.getenv("ANTHROPIC_API_KEY")
        self.client = Anthropic(api_key=self.api_key)
        self.model = "claude-3-5-sonnet-20241022"

        # Inicializar subagentes
        self.subagents = [
            SearchAgent(self.api_key),
            AnalysisAgent(self.api_key),
            TestAgent(self.api_key),
        ]

    def analyze_project(self, project_path: str) -> dict[str, Any]:
        """
        Analiza un proyecto completo usando subagentes en paralelo.

        Args:
            project_path: Ruta al proyecto

        Returns:
            An√°lisis completo agregado
        """
        print("=" * 60)
        print("üöÄ An√°lisis de proyecto con subagentes")
        print("=" * 60)

        # Definir tareas para cada subagente
        tasks = {
            "SearchAgent": f"""Analiza la estructura del proyecto en {project_path}.

Busca:
1. Archivos principales (api.py, main.py, etc.)
2. Tests existentes
3. Archivos de configuraci√≥n importantes

Retorna SOLO un resumen con las ubicaciones clave.""",
            "AnalysisAgent": f"""Analiza la calidad del c√≥digo en {project_path}.

Enf√≥cate en:
1. Estructura general del proyecto
2. Patrones arquitect√≥nicos usados
3. Principales code smells si los hay

S√© breve - m√°ximo 10 l√≠neas.""",
            "TestAgent": f"""Eval√∫a la estrategia de testing en {project_path}.

Verifica:
1. ¬øHay tests? ¬øD√≥nde?
2. ¬øQu√© tipos de tests? (unit, integration)
3. ¬øHay gaps obvios?

Respuesta concisa - m√°ximo 8 l√≠neas.""",
        }

        # Ejecutar subagentes en paralelo
        print("\n‚ö° Ejecutando subagentes en paralelo...\n")
        results = self._execute_parallel(tasks)

        # Mostrar resultados individuales
        for result in results:
            print(f"\n--- {result.agent_name} ---")
            print(f"‚è±Ô∏è  Tiempo: {result.execution_time:.2f}s")
            if result.success:
                print(f"‚úÖ Output:\n{result.output}")
            else:
                print(f"‚ùå Error: {result.error}")

        # Sintetizar resultados
        print("\n" + "=" * 60)
        print("üß† Sintetizando resultados...")
        print("=" * 60)

        synthesis = self._synthesize_results(results)

        return {
            "project_path": project_path,
            "timestamp": datetime.now().isoformat(),
            "subagent_results": [
                {
                    "agent": r.agent_name,
                    "success": r.success,
                    "execution_time": r.execution_time,
                    "output": r.output[:200] + "..." if len(r.output) > 200 else r.output,
                }
                for r in results
            ],
            "synthesis": synthesis,
            "total_execution_time": sum(r.execution_time for r in results),
        }

    def _execute_parallel(self, tasks: dict[str, str]) -> list[SubagentResult]:
        """
        Ejecuta subagentes en paralelo usando ThreadPoolExecutor.

        Args:
            tasks: {agent_name: task_description}

        Returns:
            Lista de resultados de todos los subagentes
        """
        results: list[SubagentResult] = []

        # Usar ThreadPoolExecutor para paralelizaci√≥n
        with ThreadPoolExecutor(max_workers=len(self.subagents)) as executor:
            # Crear futures
            future_to_agent = {}
            for agent in self.subagents:
                if agent.name in tasks:
                    future = executor.submit(agent.execute, tasks[agent.name])
                    future_to_agent[future] = agent.name

            # Recoger resultados a medida que se completan
            for future in as_completed(future_to_agent):
                agent_name = future_to_agent[future]
                print(f"‚úì {agent_name} completado")
                results.append(future.result())

        return results

    def _synthesize_results(self, results: list[SubagentResult]) -> str:
        """
        Sintetiza los resultados de todos los subagentes en un an√°lisis coherente.

        Usa Claude para agregar y sintetizar la informaci√≥n.
        """
        # Preparar contexto con todos los resultados
        context = "Resultados de an√°lisis de proyecto por subagentes especializados:\n\n"

        for result in results:
            context += f"--- {result.agent_name} ---\n"
            if result.success:
                context += f"{result.output}\n\n"
            else:
                context += f"ERROR: {result.error}\n\n"

        # Pedir s√≠ntesis a Claude
        response = self.client.messages.create(
            model=self.model,
            max_tokens=1024,
            messages=[
                {
                    "role": "user",
                    "content": f"""{context}

Sintetiza estos an√°lisis en un reporte ejecutivo coherente.

Estructura:
1. Resumen general (2-3 l√≠neas)
2. Hallazgos clave (bullets)
3. Recomendaciones prioritarias (m√°x 3)

M√°ximo 15 l√≠neas total. S√© conciso y accionable.""",
                }
            ],
        )

        return response.content[0].text


def main() -> None:
    """Ejemplo de uso del agente maestro con subagentes."""
    print("=== Agente Maestro con Subagentes Especializados ===\n")

    if not os.getenv("ANTHROPIC_API_KEY"):
        print("‚ùå Error: Configura ANTHROPIC_API_KEY")
        return

    # Crear agente maestro
    master = MasterAgent()

    # Analizar proyecto (directorio actual)
    project_path = input("\nRuta al proyecto a analizar (Enter para '.'): ").strip() or "."

    print(f"\nüîç Analizando proyecto: {project_path}\n")

    # Ejecutar an√°lisis
    result = master.analyze_project(project_path)

    # Mostrar s√≠ntesis final
    print("\n" + "=" * 60)
    print("üìä REPORTE FINAL")
    print("=" * 60)
    print(result["synthesis"])

    print(f"\n‚è±Ô∏è  Tiempo total de ejecuci√≥n: {result['total_execution_time']:.2f}s")
    print(f"    (Ejecuci√≥n paralela - sin paralelizaci√≥n: ~{sum(r['execution_time'] for r in result['subagent_results']):.2f}s)")


if __name__ == "__main__":
    main()


# ================================
# EJERCICIO PARA EL ESTUDIANTE
# ================================

"""
1. Ejecuta el agente maestro en diferentes proyectos
2. Mide el speedup de paralelizaci√≥n vs ejecuci√≥n secuencial
3. Observa c√≥mo cada subagente se especializa en su √°rea

4. Modifica el c√≥digo para:
   a) A√±adir un nuevo subagente: SecurityAgent (analiza vulnerabilidades)
   b) Implementar timeout por subagente (10s m√°ximo)
   c) A√±adir retry logic si un subagente falla

5. DESAF√çO: Implementa estas mejoras:
   - Subagentes as√≠ncronos usando asyncio en lugar de threads
   - Cache de resultados de subagentes (si el proyecto no cambi√≥)
   - Priorizaci√≥n: subagentes cr√≠ticos primero, otros despu√©s
   - Dashboard en terminal (rich library) mostrando progreso en vivo

6. Experimenta con paralelizaci√≥n:
   - ¬øCu√°ntos subagentes puedes ejecutar en paralelo antes de throttling de API?
   - ¬øC√≥mo afecta el max_tokens de cada subagente al rendimiento?
   - ¬øVale la pena la complejidad de subagentes vs un agente monol√≠tico?

Preguntas de reflexi√≥n:
- ¬øCu√°ndo es apropiado usar subagentes vs un agente √∫nico?
- ¬øQu√© trade-offs hay entre especializaci√≥n y flexibilidad?
- ¬øC√≥mo manejar√≠as dependencias entre subagentes?
  (ej: AnalysisAgent necesita resultados de SearchAgent)
- ¬øC√≥mo escalar√≠as esto a 10+ subagentes?
"""
