# Comparación: Manual vs IA vs Híbrido

## 1. Versión Manual (`tareas.py`)

**Ventajas**:
- [Escribe 2-3 ventajas que experimentaste al programar manualmente]
- Ejemplo: "Entiendo cada línea porque la escribí yo"
- Ejemplo: "Aprendí cómo funcionan los argumentos de terminal"

**Desventajas**:
- [Escribe 2-3 desventajas]
- Ejemplo: "Me llevó mucho tiempo"
- Ejemplo: "El código es muy básico comparado con la IA"

**Lo que aprendí**:
- [Qué aprendiste haciendo esto manualmente]
- Ejemplo: "Entendí el concepto de parsing de argumentos desde cero"

---

## 2. Versión IA (`tareas_ia_completo.py` o `tareas-json.py`)

**Ventajas**:
- [Qué hizo la IA que fue impresionante]
- Ejemplo: "Generó código production-ready en segundos"
- Ejemplo: "Incluyó manejo de errores que no había considerado"

**Desventajas**:
- [Qué generó que no necesitabas o no entendías]
- Ejemplo: "Usó `argparse` y no sé bien cómo funciona"
- Ejemplo: "Añadió timestamps ISO que no pedí"

**Lo que me sorprendió**:
- [Features inesperados que añadió la IA]
- Ejemplo: "Separó el código en capas (persistencia, dominio, CLI)"
- Ejemplo: "Incluyó docstrings en todas las funciones"

---

## 3. Versión Híbrida (`tareas_hybrid.py`)

**De la versión manual conservé**:
- [Qué partes mantuviste de tu código manual]
- Ejemplo: "La simplicidad de `sys.argv` para validación básica"
- Ejemplo: "Los nombres de variables claros que elegí"

**De la versión IA adopté**:
- [Qué mejoras de la IA integraste]
- Ejemplo: "Las docstrings porque documenta bien el código"
- Ejemplo: "La función `mostrar_uso()` separada para reutilizarla"

**Rechacé de la versión IA**:
- [Qué descartaste y por qué]
- Ejemplo: "Type hints porque aún no los domino"
- Ejemplo: "Timestamps ISO porque añaden complejidad innecesaria"

**Decisiones de diseño**:
- [Por qué elegiste esta combinación]
- Ejemplo: "Quise código que entienda 100% pero con mejor estructura"

---

## 4. Reflexión Final

**¿Cuál versión usarías en un proyecto real?**
- [Tu respuesta razonada]
- Ejemplo: "La híbrida, porque combina comprensión y buenas prácticas"
- Ejemplo: "Depende: para aprender usaría manual, para producción usaría IA"

**¿Cuándo usarías solo IA (sin modificar nada)?**
- [Escenarios donde IA sola es suficiente]
- Ejemplo: "Scripts de automatización simples que no necesito mantener"
- Ejemplo: "Cuando ya conozco el patrón y solo quiero ir rápido"

**¿Cuándo evitarías la IA completamente?**
- [Cuándo es mejor ir 100% manual]
- Ejemplo: "Cuando estoy aprendiendo un concepto nuevo"
- Ejemplo: "Código crítico de seguridad o lógica de negocio compleja"

**¿Qué aprendí sobre prompts efectivos?**
- [Lecciones de prompt engineering]
- Ejemplo: "Ser específico (framework, versión, features) da mejores resultados"
- Ejemplo: "Pedir código con docstrings y sin dependencias externas"

**Principal aprendizaje de esta clase**:
- [Tu mayor insight sobre desarrollo manual vs IA-asistido]
- Ejemplo: "La IA es una herramienta, no un reemplazo. Debo entender el código"
- Ejemplo: "Manual para aprender, IA para acelerar lo que ya domino"

---

## 5. Tabla Comparativa Final

| Criterio              | Manual | IA     | Híbrido |
|----------------------|--------|--------|---------|
| Tiempo de desarrollo | [1-5] | [1-5]  | [1-5]   |
| Comprensión del código| [1-5] | [1-5]  | [1-5]   |
| Calidad del código   | [1-5] | [1-5]  | [1-5]   |
| Mantenibilidad       | [1-5] | [1-5]  | [1-5]   |
| Aprendizaje obtenido | [1-5] | [1-5]  | [1-5]   |

*(Escala: 1 = Bajo, 5 = Alto)*

---

## 6. Próximos Pasos

Después de esta clase, quiero aprender:
- [ ] `argparse` más a fondo (lo que usó la IA)
- [ ] Cómo hacer tests para CLI en Python
- [ ] El patrón Repository (separar persistencia de lógica)
- [ ] Prompt engineering avanzado
- [ ] [Añade lo que TÚ quieras aprender]
