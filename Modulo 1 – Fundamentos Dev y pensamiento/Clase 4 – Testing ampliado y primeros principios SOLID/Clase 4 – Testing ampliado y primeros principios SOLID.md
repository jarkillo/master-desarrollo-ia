# Clase 4 ‚Äì Testing ampliado y primeros principios SOLID

### Escenario inicial

Ya tienes un CLI que:

- Agrega tareas.
- Lista tareas.
- Marca tareas como completadas.
- Tiene **tests unitarios b√°sicos** (agregar, completar, listar).

Hasta aqu√≠, bien.

Pero en el mundo real, la historia no se detiene. Te piden una **nueva feature**: *‚Äúnecesitamos prioridades en las tareas (alta, media, baja) y poder filtrarlas‚Äù*.

Tu reacci√≥n natural como dev novato podr√≠a ser:

*‚ÄúBueno, meto un nuevo campo `prioridad` en el diccionario y apa√±o las funciones para que lo impriman‚Äù*.

### El problema

Si haces eso sin cuidado:

- Cambias la estructura de datos ‚Üí **rompes funciones** sin darte cuenta.
- Los tests que escribiste antes quiz√°s fallen, o peor: no fallen aunque el programa ya tenga inconsistencias.
- El archivo empieza a tener funciones que hacen demasiadas cosas (olor a spaghetti).

Aqu√≠ es donde se juntan dos ideas:

1. **Tests m√°s fuertes** ‚Üí te avisan de qu√© rompiste al tocar la estructura.
2. **Principio de responsabilidad √∫nica (SRP de SOLID)** ‚Üí cada funci√≥n o m√≥dulo debe tener un motivo √∫nico para cambiar.

---

üëâ Primer mini-ejercicio:

Mira tu funci√≥n `agregar_tarea` actual. Si ahora necesita guardar tambi√©n `prioridad`, ¬øqu√© cambiar√≠as exactamente en esa funci√≥n y en sus tests?

(Haz un apunte mental o an√≥talo en tu repo. No lo codifiques a√∫n. Queremos ver d√≥nde empieza a doler antes de sacar la ‚Äúcura‚Äù).

¬øSe te ha ocurrido esto?

En la clase:

```
# ================================
# 1.1. TIPOS DE DATOS
# ================================
class Tarea(TypedDict):
    id: int
    nombre: str
    completada: bool
    prioridad: str 
```

En agregar tarea

```sql
def agregar_tarea(ruta: str, nombre: str, prioridad: str) -> Tarea:
    """Crea una nueva tarea no completada y la persiste."""

    tareas = cargar_tareas(ruta)
    tarea: Tarea = {"id": nuevo_id(tareas), "nombre": nombre, "completada": False, "prioridad": prioridad}
    tareas.append(tarea)
    guardar_tareas(ruta, tareas)
    return tarea  # devolver la entidad ayuda en tests 
```

Exacto, ese es el movimiento natural: a√±adir un campo nuevo y extender la funci√≥n.

Lo interesante es que al hacerlo‚Ä¶ ya has creado **un punto de dolor**:

1. Todos los lugares donde se llama a `agregar_tarea` ahora **rompen**, porque piden solo `(ruta, nombre)` y t√∫ exiges `(ruta, nombre, prioridad)`.
2. Tus **tests anteriores** tampoco compilan ni pasan, porque no saben qu√© es `prioridad`.
3. Si alguien se olvida de pasar la prioridad, se l√≠a.

Y aqu√≠ entra la magia de lo que estamos aprendiendo hoy:

- **Los tests te sirven de alarma**: si tu cambio rompe algo, lo detectas antes de usar el programa.
- **SOLID te da br√∫jula**: ‚Äúcada funci√≥n deber√≠a tener un √∫nico motivo para cambiar‚Äù. Tu funci√≥n `agregar_tarea` est√° asumiendo varias responsabilidades (crear estructura, decidir ID, meter la prioridad, guardar en disco).

---

Lo que vamos a hacer ahora es **reforzar un test existente** para incluir la prioridad, antes incluso de tocar m√°s funciones. As√≠ practicamos c√≥mo los tests te dan red de seguridad.

Por ejemplo, tu test de agregar podr√≠a ampliarse as√≠:

```python
def test_agregar_tarea_con_prioridad(self):
    t = agregar_tarea(self.tmp, "Estudiar IA", "alta")
    tareas = cargar_tareas(self.tmp)
    self.assertEqual(len(tareas), 1)
    self.assertEqual(tareas[0]["nombre"], "Estudiar IA")
    self.assertEqual(tareas[0]["prioridad"], "alta")
    self.assertFalse(tareas[0]["completada"])

```

Si corres este test ahora, ¬øqu√© pasar√°?

- Si ya cambiaste la funci√≥n como escribiste, pasar√° ‚úÖ.
- Si alguien sigue usando la versi√≥n vieja de `agregar_tarea`, fallar√° ‚ùå.

¬øQue sucedio? ¬øTe ha ocurrido este error?

```sql
======================================================================
ERROR: test_completar_tarea (__main__.TestTareas.test_completar_tarea)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "e:\master-ia-manu\Modulo 1 ‚Äì Fundamentos Dev y pensamiento\Clase 4 ‚Äì Testing ampliado y primeros principios SOLID\cli-tareas\test_tareas.py", line 41, in test_completar_tarea
    tarea = agregar_tarea(self.tmp, "Repasar Git")
TypeError: agregar_tarea() missing 1 required positional argument: 'prioridad'

======================================================================
ERROR: test_listar_con_tareas (__main__.TestTareas.test_listar_con_tareas)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "e:\master-ia-manu\Modulo 1 ‚Äì Fundamentos Dev y pensamiento\Clase 4 ‚Äì Testing ampliado y primeros principios SOLID\cli-tareas\test_tareas.py", line 63, in test_listar_con_tareas
    agregar_tarea(self.tmp, "Estudiar IA")
    ~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: agregar_tarea() missing 1 required positional argument: 'prioridad'

----------------------------------------------------------------------
Ran 5 tests in 0.009s

FAILED (errors=2)
```

Perfecto: tus tests han fallado **como deben**. Has cambiado la firma de `agregar_tarea` y los tests antiguos no pasan la nueva `prioridad`. Antes de ponernos finos con SOLID, vamos a **desbloquear la suite** sin romper a nadie.

## Paso 1 ‚Äî Cambio no rompedor (retrocompatibilidad)

Haz que `agregar_tarea` acepte una prioridad **por defecto**. As√≠ los tests antiguos (que no pasan prioridad) vuelven a funcionar y podemos migrarlos con calma.

```python
from typing import Literal

PRIORIDADES = ("alta", "media", "baja")

def _normaliza_prioridad(p: str) -> str:
    p = (p or "").lower()
    return p if p in PRIORIDADES else "media"

def agregar_tarea(ruta_archivo: str, nombre_tarea: str, prioridad: str = "media") -> dict:
    """Crea una tarea (por defecto prioridad='media'), la guarda y la devuelve."""
    if prioridad not in PRIORIDADES_VALIDAS:
        prioridad = "media"

    lista_tareas = cargar_tareas(ruta_archivo)

    nueva_tarea = {
        "id": nuevo_id(lista_tareas),
        "nombre": nombre_tarea,
        "completada": False,
        "prioridad": prioridad,
    }

    lista_tareas.append(nueva_tarea)
    guardar_tareas(ruta_archivo, lista_tareas)
    return nueva_tarea

```

Antes de cambiar nada, he colado un detallito que seguro que habras visto en los codigos que te ha dado la IA.

una variable llamada p.

Quizas, cuando lo escribe la IA o lo escribes tu, lo entiendes del tir√≥n. Pero‚Ä¶ ¬øQu√© ocurrir√° dentro de 6 meses? ¬øY si le das este codigo a otro desarrollador?

Va a perder horas trazando el codigo para descubrir que querias decir con ‚Äúp‚Äù

Esto es algo que la IA hace con muchisima frecuencia. Y si te dedicas a copiar y pegar, luego no entender√°s nada de lo que est√° haciendo.

Un dev humano que lea `t["prioridad"]` o una variable llamada `t` se queda pensando: ‚Äú¬øt de qu√©? ¬øtrabajo? ¬øtask? ¬øtaza de caf√©?‚Äù

Esto conecta directamente con **Clean Code** y con el primer principio de **SOLID (Single Responsibility Principle)**: cada parte del c√≥digo deber√≠a contar su historia de forma clara y tener un √∫nico motivo para cambiar. Si encima usas nombres cr√≠pticos, la historia se convierte en jerogl√≠fico.

la forma correcta ser√≠a:

```sql
PRIORIDADES = ("alta", "media", "baja")

def _normaliza_prioridad(prioridad: str) -> str:
    """Devuelve la prioridad normalizada o 'media' si es inv√°lida."""
    prioridad_normalizada = (prioridad or "").lower()
    return prioridad_normalizada if prioridad_normalizada in PRIORIDADES else "media"
```

Siempre hay que preocuparse de dejar c√≥digo legible.

## Paso 2 ‚Äî Backfill suave al leer (por si hay JSON viejo)

Si ya tienes `tareas.json` (porque has ejecutado el programa) sin el campo, a√±adimos la prioridad al vuelo al cargar para que nada explote.

```python
def cargar_tareas(ruta_archivo: str) -> list[dict]:
    if not os.path.exists(ruta_archivo):
        return []

    try:
        with open(ruta_archivo, "r", encoding="utf-8") as fichero:
            contenido = fichero.read().strip()
            lista_tareas = json.loads(contenido) if contenido else []
    except json.JSONDecodeError:
        return []

    # Aseguramos que cada tarea tenga 'prioridad'
    for tarea in lista_tareas:
        if "prioridad" not in tarea or tarea["prioridad"] not in PRIORIDADES_VALIDAS:
            tarea["prioridad"] = "media"

    return lista_tareas

```

Con esto, tus dos tests que llamaban `agregar_tarea(self.tmp, "‚Ä¶")` **dejan de petar** porque la prioridad tiene valor por defecto.

## Paso 3 ‚Äî A√±ade 1 test nuevo (cubrir la nueva feature)

Ahora s√≠, sumamos una prueba m√≠nima para la prioridad (sin reescribir todo tu suite):

```python
def test_agregar_tarea_prioridad_por_defecto(self):
    nueva = agregar_tarea(self.tmp, "Repasar SOLID")  # sin prioridad
    self.assertEqual(nueva["prioridad"], "media")

def test_agregar_tarea_con_prioridad_alta(self):
    nueva = agregar_tarea(self.tmp, "Estudiar IA", "alta")
    self.assertEqual(nueva["prioridad"], "alta")
```

## Mini check de dise√±o (SRP en miniatura)

- **Antes** `agregar_tarea` romp√≠a llamadas antiguas ‚Üí m√∫ltiples motivos de cambio a la vez.
- **Ahora** aislamos el cambio con un **valor por defecto** + **normalizaci√≥n** + **backfill en carga**. Una cosa a la vez; tests verdes; cabeza fr√≠a.

## Qu√© sigue

Cuando confirmes que **tu suite est√° en verde**, atacamos **filtrar por prioridad** en `listar_tareas` con el mismo estilo:

1. escribimos **un test** s√∫per claro,
2. implementamos **lo m√≠nimo** para pasarlo,
3. nombres largos y cero magia.

Dime cuando tengas los tests verdes y seguimos con el filtro.

## Antes de continuar

¬øTe has dado cuenta de que hemos hecho una funci√≥n que empieza por _? ¬øEs magia?

En Python, cuando ves una funci√≥n o variable con **guion bajo delante** (`_normaliza_prioridad`, `_variable`), significa:

- **Convenci√≥n.**
    
    No cambia c√≥mo funciona Python. Es simplemente una forma de decir: *‚Äúesto es interno, no lo llames desde fuera del m√≥dulo‚Äù*.
    
- Ejemplo en castellano:
    - `agregar_tarea()` ser√≠a la ‚Äúpuerta principal‚Äù del restaurante: la funci√≥n que cualquier cliente puede usar.
    - `_normaliza_prioridad()` ser√≠a la ‚Äúcocina interna‚Äù: existe para ayudar, pero no est√° pensada para que el cliente meta mano ah√≠.
- El guion bajo es un **aviso para humanos y para linters** (programas que revisan tu estilo de c√≥digo):
    
    *‚ÄúEsto es privado. Si lo usas fuera, bajo tu responsabilidad‚Äù*.
    

En tu caso, quiz√°s **yo met√≠ `_normaliza_prioridad()` demasiado pronto**, y te di un dolor de cabeza extra cuando todav√≠a est√°s asentando cosas.

Vamos a dejarlo as√≠ para evitar complicarlo, simplemente debes entender que:

- Si empieza por _ , es una funcion interna (una funcion que ayuda a otra funci√≥n que si puede ser llamada desde fuera.

¬øEsto provoca que no puedas llamarla desde fuera?

NO, tan solo es una forma de escribirlo para que los humanos y programas automaticos lo entiendan. Escribir con buenas convenciones ayudar√° tambien a la IA a entender.

## ¬øseguimos?

Hasta ahora en la clase hemos hecho:

- **Problema real**: ‚Äútu CLI empieza a crecer, el jefe pide prioridad en las tareas‚Äù.
- **Primer choque**: al a√±adir `prioridad` rompimos los tests ‚Üí vimos c√≥mo los tests son tu red de seguridad.
- **Soluci√≥n did√°ctica**: a√±adimos `prioridad` con valor por defecto, explicamos la convenci√≥n del `_` y dejamos el c√≥digo **claro y legible**.

Vale, quiero dejar algo claro. Es posible que ahora mismo digas:

- No entiendo los codigos de los tests
- No entiendo muchas partes del codigo python que se esta escribiendo
- Me estoy aturullando de tanta informaci√≥n de golpe

Si esto es as√≠, necesitas refrescar conceptos.

1. Esto es un master para desarrollar con IA, el objetivo no es que sepas todo el codigo de memoria, sino que lo entiendas al leerlo y que tengas los conceptos de la metodolog√≠a que quieres seguir.
2. En Internet hay muchos cursos de Python b√°sicos. Antes de continuar, te recomiendo que te los mires, aunque sea rapidamente, sin pararte a memorizar todo.
3. Si quieres aprender a hacer test con profundidad, hay muchos cursos de testing en programaci√≥n.

MI objetivo ahora mismo es montar un esquema mental, que te indique como se debe de programar, crear proyectos y hacer aplicaciones escalables. No es tanto que seas un experto en testing o en python. Para eso ya hay muchos cursos gratuitos que cubren esos aspectos.

Po tanto, lo que quiero que ahora mismo tengas claro en tu cabeza es:

1. Un proyecto empieza con un repo de git, para permitirnos volver atras si nos cargamos el proyecto entero
2. Antes de realiza cualquier cambio en la aplicacion, hacemos una rama (branch) y ah√≠ hacemos los cambios. Si todo est√° correcto, hacemos pull request para escribir los cambios en la rama principal (o en la rama dev, como veremos mas adelante)
3. Si queremos usar TDD (Y con IA es lo mejor), primero se hacen los test y luego se programan las funciones
4. Los test verifican casos de uso (historias de usuario), y comprueban que la salida devuelva lo que debe devolver.
5. Para modificar funciones, primero debemos modificar los test y luego modificar la funcion.
6. A la IA se le pide codigo con una estructura, contexto y en pasos peque√±os:
    1. Rol
    2. Tarea
    3. Objetivo
7. Siempre dividimos el problema es funciones con una sola responsabilidad, y a la IA le iremos dando estas tareas.
8. La IA escribe abreviaturas, pidele que no lo haga y siempre haz codigo limpio y legible. Si tu no lo entiendes, est√° mal.
9. Antes de hacer PR los test deben pasar.
10. Los test deben cubrir todas las posibilidades que puedan ocurrirle a un usuario. (Esto antes para un programador era practicamente imposible, debido a los presupuestos, ahora con la IA es posible hacerlo, y es necesario.

Vale, ahora que tienes en la cabeza este esquema de trabajo, vamos a a√±adir una **nueva historia de usuario**: listar tareas filtradas por prioridad.

Lo atacamos con TDD: primero un test que exprese esa historia, luego el c√≥digo m√≠nimo para que pase.

### La historia contin√∫a

Imagina que tu CLI de tareas ya lo usas en tu d√≠a a d√≠a. Has agregado varias tareas con distinta prioridad:

- Estudiar IA ‚Üí prioridad alta
- Repasar Git ‚Üí prioridad baja
- Llamar a tu madre ‚Üí prioridad media

Hasta aqu√≠ todo bien.

Pero un d√≠a, con la lista llena de cosas, piensas:

*"Necesito ver solo lo que es **urgente**. No quiero que se me pierda entre todo lo dem√°s."*

Ese es el **nuevo problema** que enfrentamos: **filtrar tareas por prioridad**.

Y es perfecto para practicar **TDD + SRP**: escribir primero el test, luego el c√≥digo m√≠nimo, y asegurarnos de que la funci√≥n hace **una sola cosa clara**.

### Paso 1 ‚Äî Escribir el test (el contrato)

Antes de tocar c√≥digo, describimos la historia como prueba automatizada:

```python
def test_listar_solo_prioridad_alta(self):
    agregar_tarea(self.tmp, "Estudiar IA", "alta")
    agregar_tarea(self.tmp, "Repasar Git", "baja")
    agregar_tarea(self.tmp, "Llamar a mam√°", "media")

    tareas_alta = listar_tareas(self.tmp, prioridad="alta")

    # Debe haber exactamente 1 tarea
    self.assertEqual(len(tareas_alta), 1)
    
    # Esa tarea debe ser la de "Estudiar IA"
    self.assertEqual(tareas_alta[0]["nombre"], "Estudiar IA")
    self.assertEqual(tareas_alta[0]["prioridad"], "alta")

```

Este test cuenta la historia: *‚Äúcuando filtro por prioridad alta, solo me devuelve esas tareas‚Äù*.

### Paso 2 ‚Äî Implementar lo m√≠nimo

Ahora s√≠, ampliamos `listar_tareas` para aceptar un filtro opcional:

```python
def listar_tareas(ruta_archivo: str, prioridad: str | None = None) -> list[dict]:
    """Devuelve la lista de tareas. Si se pasa prioridad, filtra por ella."""
    todas = cargar_tareas(ruta_archivo)

    if prioridad is None:
        return todas

    return [tarea for tarea in todas if tarea.get("prioridad") == prioridad]

```

- **Si no pasas prioridad** ‚Üí devuelve todas (como hasta ahora).
- **Si pasas prioridad** ‚Üí devuelve solo las que coincidan.

### Paso 3 ‚Äî Relaci√≥n con SRP (Single Responsibility Principle)

F√≠jate qu√© hemos hecho aqu√≠:

- `listar_tareas` tiene **una responsabilidad clara**: devolver tareas.
- Si adem√°s le pides filtrar, lo hace, pero sigue siendo **coherente con su prop√≥sito**.
- No imprime, no escribe en archivos, no cambia datos. Solo **lee y selecciona**.

Esto es SRP en miniatura: una funci√≥n que tiene **un √∫nico motivo para cambiar** ‚Üí si ma√±ana cambia c√≥mo se guardan las prioridades, tocar√≠as aqu√≠; pero si cambia c√≥mo se imprimen en el CLI, eso va en otro lado.

---

## ü§ñ Workflow TDD con IA: RED ‚Üí GREEN ‚Üí REFACTOR

Hasta ahora has visto el ciclo TDD b√°sico. Ahora vamos a potenciarlo con **Test Coverage Strategist** y **Python Best Practices Coach** para hacer TDD profesional.

### RED: Escribir tests que fallen (Con ayuda de IA)

**Problema**: Cuando a√±ades una feature nueva (ej. prioridades), ¬øqu√© casos debes testear?

**Soluci√≥n**: Pedir al Test Coverage Strategist una lista COMPLETA de casos.

#### Paso RED.1: Define la feature (Manual)

```markdown
Feature: Sistema de prioridades (alta/media/baja)
- agregar_tarea debe aceptar par√°metro prioridad
- listar_tareas debe filtrar por prioridad
```

#### Paso RED.2: Pide casos de prueba a IA

**Prompt al Test Coverage Strategist**:

```
Rol: Test Coverage Strategist
Feature nueva: Sistema de prioridades en tareas (alta/media/baja)

Funcionalidad:
- agregar_tarea(ruta, nombre, prioridad="media")
- listar_tareas(ruta, prioridad=None)

Objetivo: Lista de casos de prueba para TDD.
Categoriza por criticidad (Alta/Media/Baja).
```

**IA responde**:

```markdown
### Criticidad ALTA:
1. Agregar con prioridad expl√≠cita "alta"
2. Agregar sin prioridad (default "media")
3. Prioridad inv√°lida usa "media"
4. Filtrar por prioridad "alta"
5. Listar sin filtro devuelve todas
6. Backward compatibility: tareas antiguas sin prioridad

### Criticidad MEDIA:
7. Filtrar prioridad sin resultados ‚Üí []
8. Case-insensitive ("ALTA" ‚Üí "alta")

### Criticidad BAJA:
9. Todas las prioridades (parametrizaci√≥n)
```

#### Paso RED.3: Escribir tests que FALLEN (Manual)

**‚ö†Ô∏è IMPORTANTE**: T√ö escribes los tests, la IA solo sugiri√≥ QU√â testear.

```python
# test_tareas_pytest_prioridades.py

def test_agregar_tarea_prioridad_alta(archivo_temporal):
    """Test RED: Este fallar√° porque feature no existe."""
    tarea = agregar_tarea(archivo_temporal, "Urgente", prioridad="alta")
    assert tarea["prioridad"] == "alta"
    # ‚ùå TypeError: agregar_tarea() got unexpected keyword 'prioridad'


def test_listar_solo_prioridad_alta(archivo_temporal):
    """Test RED: Filtrado no implementado a√∫n."""
    agregar_tarea(archivo_temporal, "Urgente", prioridad="alta")
    agregar_tarea(archivo_temporal, "Normal", prioridad="media")

    altas = listar_tareas(archivo_temporal, prioridad="alta")

    assert len(altas) == 1
    assert altas[0]["nombre"] == "Urgente"
    # ‚ùå TypeError: listar_tareas() got unexpected keyword 'prioridad'
```

**Ejecuta tests** (deben fallar ‚ùå):
```bash
pytest test_tareas_pytest_prioridades.py -v
```

**‚úÖ Fase RED completa**: Tienes tests que describen la feature pero fallan.

---

### GREEN: Implementaci√≥n m√≠nima (Con ayuda de IA)

**Objetivo**: Hacer que los tests pasen con el c√≥digo M√çN IMO necesario.

#### Paso GREEN.1: Pedir implementaci√≥n a IA

**Prompt**:

```
Rol: Python developer
Contexto: Tengo tests RED que fallan (feature prioridades no existe).

Tests que deben pasar:
[pega los tests de arriba]

C√≥digo actual:
[pega agregar_tarea y listar_tareas]

Objetivo: Modifica funciones para que pasen tests.
Requisitos:
- Par√°metro opcional prioridad="media"
- Validar prioridades v√°lidas (alta/media/baja)
- Filtrado opcional en listar_tareas
- Type hints
```

**IA genera**:

```python
PRIORIDADES_VALIDAS = ("alta", "media", "baja")

def agregar_tarea(ruta: str, nombre: str, prioridad: str = "media") -> dict:
    if prioridad not in PRIORIDADES_VALIDAS:
        prioridad = "media"

    tareas = cargar_tareas(ruta)
    nueva = {
        "id": nuevo_id(tareas),
        "nombre": nombre,
        "completada": False,
        "prioridad": prioridad
    }
    tareas.append(nueva)
    guardar_tareas(ruta, tareas)
    return nueva


def listar_tareas(ruta: str, prioridad: str | None = None) -> list[dict]:
    todas = cargar_tareas(ruta)
    if prioridad is None:
        return todas
    return [t for t in todas if t.get("prioridad") == prioridad]
```

#### Paso GREEN.2: Revisar c√≥digo (Manual)

**T√ö decides**:
- ¬øEntiendes cada l√≠nea?
- ¬øSigue SRP?
- ¬øEs el m√≠nimo o a√±ade complejidad innecesaria?

**Si no entiendes algo**, pregunta a la IA:
```
Explica esta l√≠nea: return [t for t in todas if t.get("prioridad") == prioridad]
```

#### Paso GREEN.3: Ejecutar tests (deben pasar ‚úÖ)

```bash
pytest test_tareas_pytest_prioridades.py -v
```

**Resultado esperado**:
```
test_agregar_tarea_prioridad_alta PASSED
test_listar_solo_prioridad_alta PASSED
```

**‚úÖ Fase GREEN completa**: Feature implementada, tests pasan.

---

### REFACTOR: Limpieza con IA (Python Best Practices Coach)

**Objetivo**: C√≥digo funciona, ahora lo hacemos PYTHONIC.

#### Paso REFACTOR.1: Pedir revisi√≥n al Coach

**Prompt al Python Best Practices Coach**:

```
Rol: Python Best Practices Coach
Contexto: Implement√© prioridades. Tests pasan ‚úÖ.

C√≥digo:
[pega agregar_tarea y listar_tareas]

Objetivo: Sugiere mejoras Pythonic (NO cambies funcionalidad).
- Anti-patterns detectados
- Type hints m√°s espec√≠ficos
- C√≥digo m√°s idiom√°tico
```

**Coach sugiere**:

```markdown
## Mejoras Pythonic

### 1. Type hints espec√≠ficos con Literal
‚ùå Antes: `prioridad: str = "media"`
‚úÖ Despu√©s: `prioridad: Literal["alta", "media", "baja"] = "media"`

**Ventaja**: IDE detecta typos ("medio" dar√≠a error)

### 2. Extraer validaci√≥n a funci√≥n helper
‚ùå Antes: `if prioridad not in PRIORIDADES_VALIDAS:`
‚úÖ Despu√©s: `_normalizar_prioridad(prioridad: str) -> Literal[...]`

**Ventaja**: C√≥digo m√°s limpio, funci√≥n tiene un solo prop√≥sito

### 3. List comprehension est√° OK ‚úÖ
Tu c√≥digo `[t for t in todas if t.get("prioridad") == prioridad]` es Pythonic.
```

#### Paso REFACTOR.2: Aplicar mejoras (Manual)

```python
from typing import Literal

Prioridad = Literal["alta", "media", "baja"]

def _normalizar_prioridad(prioridad: str) -> Prioridad:
    """Normaliza prioridad o usa 'media' si inv√°lida."""
    prioridad_lower = prioridad.lower()
    return prioridad_lower if prioridad_lower in ("alta", "media", "baja") else "media"


def agregar_tarea(ruta: str, nombre: str, prioridad: Prioridad = "media") -> dict:
    prioridad = _normalizar_prioridad(prioridad)
    # ... resto del c√≥digo
```

#### Paso REFACTOR.3: Tests deben seguir pasando

```bash
pytest test_tareas_pytest_prioridades.py -v
```

**Si fallan**, revertir cambio. **Si pasan** ‚úÖ, refactor exitoso.

**‚úÖ Fase REFACTOR completa**: C√≥digo limpio, tests pasan, SRP mantenido.

---

## üéØ Proyecto: Alcanzar 90%+ Coverage con Test Coverage Strategist

**Objetivo**: Superar el m√≠nimo (80%) y llegar a cobertura de excelencia (90%+).

### Paso 1: Coverage actual

```bash
pytest --cov=. --cov-report=term-missing
```

**Ejemplo de output**:
```
Name          Stmts   Miss  Cover   Missing
-------------------------------------------
tareas.py        45      5    89%   23-25, 67, 89
test_...py       32      0   100%
-------------------------------------------
TOTAL            77      5    93%
```

Est√°s en **89%**. Necesitas **90%+**.

### Paso 2: Invocar Test Coverage Strategist

**Prompt**:

```
Rol: Test Coverage Strategist
Contexto: Estoy en 89% coverage, quiero 90%+.

Coverage report:
[pega output pytest --cov]

C√≥digo: tareas.py completo

Objetivo: Plan priorizado de tests para alcanzar 90%+.
Identifica gaps y qu√© tests necesito.
```

**IA responde**:

```markdown
## Gaps de Coverage Detectados

### L√≠neas sin cubrir:

**L√≠nea 23-25** (tareas.py):
```python
if "prioridad" not in tarea or tarea["prioridad"] not in PRIORIDADES_VALIDAS:
    tarea["prioridad"] = "media"
```
**Criticidad**: ALTA (backward compatibility)
**Test necesario**: Cargar tarea legacy sin prioridad

**L√≠nea 67** (tareas.py):
```python
return False  # Tarea no encontrada
```
**Criticidad**: ALTA (error handling)
**Test necesario**: Completar ID inexistente

**L√≠nea 89** (tareas.py):
```python
return []  # JSON corrupto
```
**Criticidad**: MEDIA
**Test necesario**: Archivo JSON inv√°lido

### Plan para 90%+:

**Test 1** (cubre l√≠neas 23-25):
```python
def test_backfill_prioridad_tareas_legacy(archivo_temporal):
    # Simular tarea sin prioridad
    legacy = [{"id": 1, "nombre": "Antigua", "completada": False}]
    guardar_tareas(archivo_temporal, legacy)

    tareas = cargar_tareas(archivo_temporal)
    assert tareas[0]["prioridad"] == "media"
```

**Test 2** (cubre l√≠nea 67):
```python
def test_completar_tarea_id_inexistente(archivo_temporal):
    ok = completar_tarea(archivo_temporal, 999)
    assert ok == False
```

**Impacto**: +3 l√≠neas cubiertas ‚Üí **92% coverage** ‚úÖ
```

### Paso 3: Implementar tests del plan (Manual)

Escribe T√ö los tests. Verifica que cubren las l√≠neas indicadas.

### Paso 4: Parametrizaci√≥n para reducir duplicaci√≥n

**Detecta duplicaci√≥n**:

```python
def test_prioridad_alta(...): ...
def test_prioridad_media(...): ...
def test_prioridad_baja(...): ...
```

**Refactoriza con pytest.mark.parametrize**:

```python
@pytest.mark.parametrize("prioridad", ["alta", "media", "baja"])
def test_prioridades_validas(archivo_temporal, prioridad):
    tarea = agregar_tarea(archivo_temporal, f"Tarea {prioridad}", prioridad=prioridad)
    assert tarea["prioridad"] == prioridad
```

**Beneficio**: 1 test en vez de 3, m√°s mantenible.

### Paso 5: Validaci√≥n final (90%+ alcanzado)

```bash
pytest --cov=. --cov-report=html --cov-fail-under=90 -v
```

**Resultado esperado**:
```
======================== 12 passed in 0.52s ========================
Coverage: 92%
```

Abre `htmlcov/index.html` para visualizar cobertura l√≠nea por l√≠nea.

**‚úÖ √âXITO**: 90%+ coverage con tests significativos (no tests in√∫tiles).

---

## üìö Ejercicio Completo: TDD con IA (90%+ Coverage)

**Consulta**: `ejercicio_clase4_ai_avanzado.md` en esta carpeta.

**Fases del ejercicio**:
1. **RED** (20 min): Tests que fallan con lista de IA
2. **GREEN** (20 min): Implementaci√≥n m√≠nima con ayuda IA
3. **REFACTOR** (15 min): Limpieza con Python Best Practices Coach
4. **COVERAGE** (30 min): Plan con Test Coverage Strategist ‚Üí 90%+

**Entregables**:
- `test_tareas_pytest_prioridades.py` con 10+ tests
- `tareas.py` refactorizado y Pythonic
- `notes.md` documentando workflow RED-GREEN-REFACTOR
- Coverage 90%+ ‚úÖ

**Regla de oro**:
- IA sugiere QU√â testear ‚Üí T√ö escribes el c√≥digo
- IA genera plantilla ‚Üí T√ö entiendes cada l√≠nea
- IA refactoriza ‚Üí T√ö validas con tests

---

### Pausa de respiraci√≥n

¬øTe das cuenta del patr√≥n?

1. Empieza un **problema real** (quiero ver solo lo urgente).
2. Lo transformamos en un **test** (un contrato claro).
3. Escribimos el **c√≥digo m√≠nimo** para que pase.
4. Confirmamos que cada funci√≥n mantiene una **√∫nica responsabilidad**.

Ya no estamos improvisando ni escribiendo jerogl√≠ficos: estamos siguiendo una metodolog√≠a que escala.

üëâ Ejercicio de la clase:

- Crea rama `feature/cli-prioridades`.
- A√±ade el test de filtro + el cambio en `listar_tareas`.
- Corre todos los tests.
- Si todo est√° verde, haz PR.
- Documenta en `notes.md`: *‚ÄúA√±ad√≠ prioridad a tareas. Al principio se rompieron los tests. Los arregl√© con valor por defecto y ahora tambi√©n tengo filtrado por prioridad.‚Äù*

# ‚úÖ Checklist de la Clase 4 ‚Äì Testing ampliado + primer principio SOLID

### Conceptos que deben quedarte claros

- Los **tests** son tu red de seguridad: cuando cambiaste la funci√≥n `agregar_tarea` para a√±adir `prioridad`, los tests fallaron y te avisaron del problema.
- Un cambio grande debe empezar por el **test**: escribes lo que quieres comprobar, luego ajustas el c√≥digo para que lo cumpla.
- El guion bajo `_` delante de una funci√≥n o variable es solo **una convenci√≥n**: indica que es interna, pero no te impide usarla.
- **SRP (Single Responsibility Principle)** en miniatura: cada funci√≥n debe tener un motivo √∫nico para cambiar.
    - `agregar_tarea` crea y guarda.
    - `listar_tareas` devuelve y filtra.
    - No mezclan impresi√≥n ni argumentos del CLI.

### Resultado tangible del PR

- Rama nueva: `feature/cli-prioridades`.
- `agregar_tarea` ahora admite un campo `prioridad` con valor por defecto `"media"`.
- `cargar_tareas` rellena el campo si el archivo viejo no lo tiene.
- `listar_tareas` acepta un argumento opcional `prioridad` para filtrar.
- Tests a√±adidos:
    - Agregar con prioridad por defecto.
    - Agregar con prioridad expl√≠cita.
    - Listar solo las tareas de una prioridad.
- Todos los tests deben estar en verde antes de hacer el PR.

### Meta-mensaje de la clase

No necesitas ser experto en Python o unittest. Lo importante es que interiorices la **metodolog√≠a**:

1. Rama ‚Üí test ‚Üí c√≥digo m√≠nimo ‚Üí PR.
2. Funciones peque√±as y con responsabilidad clara.
3. Convenciones que ayudan a humanos, IA y al ‚Äúyo del futuro‚Äù a entender el c√≥digo.

---

üëâ Con esto, tu CLI ya empieza a parecerse a un mini-proyecto real: tiene nuevas features, tests que lo protegen y una base de dise√±o que evita que se convierta en spaghetti.

---

# üéØ Proyecto Final del M√≥dulo 1

Esta Clase 4 ES tu **proyecto final del M√≥dulo 1**. No es solo un ejercicio m√°s: es donde demuestras que dominas los fundamentos de desarrollo + asistencia de IA.

## Objetivos del Proyecto Final

Al completar este proyecto, habr√°s demostrado:

1. ‚úÖ **Git workflow profesional**: Branches, commits, Pull Requests
2. ‚úÖ **TDD con IA**: RED ‚Üí GREEN ‚Üí REFACTOR usando agentes
3. ‚úÖ **SOLID b√°sico**: Single Responsibility Principle aplicado
4. ‚úÖ **Coverage de excelencia**: 90%+ con tests significativos
5. ‚úÖ **Validaci√≥n de c√≥digo IA**: Verificar que el c√≥digo generado es correcto

---

## ü§ñ Workflow Multi-Agente del Proyecto

Este proyecto debes completarlo usando un **workflow estructurado de agentes**. No se trata de "pedirle todo a la IA", sino de usar **el agente correcto en cada fase**.

### Fase 1: RED (Dise√±o de Tests) ‚Üí Test Coverage Strategist

**Cu√°ndo usarlo**: Cuando necesites identificar QU√â casos de prueba escribir.

**C√≥mo usarlo**:

```markdown
Prompt al Test Coverage Strategist:

Rol: Test Coverage Strategist
Feature nueva: Sistema de prioridades en tareas (alta/media/baja)

Funcionalidad:
- agregar_tarea(ruta, nombre, prioridad="media")
- listar_tareas(ruta, prioridad=None)

Objetivo: Lista completa de casos de prueba para TDD.
Categoriza por criticidad (Alta/Media/Baja).
```

**Qu√© hace el agente**:
- ‚úÖ Sugiere casos de prueba (happy path, edge cases, validaci√≥n)
- ‚úÖ Prioriza por criticidad (qu√© testear primero)
- ‚úÖ Identifica casos que NO se te hab√≠an ocurrido

**QU√â HACES T√ö** (NO delegar al agente):
- ‚ùå NO copies los tests autom√°ticamente
- ‚úÖ ESCRIBE T√ö los tests bas√°ndote en las sugerencias
- ‚úÖ ENTIENDE por qu√© cada test es necesario

---

### Fase 2: GREEN (Implementaci√≥n) ‚Üí Python Best Practices Coach

**Cu√°ndo usarlo**: Despu√©s de implementar el c√≥digo (cuando tests ya pasan).

**C√≥mo usarlo**:

```markdown
Prompt al Python Best Practices Coach:

Rol: Python Best Practices Coach
Contexto: Implement√© prioridades en tareas. Tests pasan ‚úÖ.

C√≥digo:
[pega tu c√≥digo]

Objetivo: Revisa y sugiere mejoras Pythonic.
- ¬øHay anti-patterns?
- ¬øEst√°n bien los type hints?
- ¬øC√≥digo legible y mantenible?
```

**Qu√© hace el agente**:
- ‚úÖ Detecta anti-patterns (variables `p`, `t`, c√≥digo cr√≠ptico)
- ‚úÖ Sugiere mejoras Pythonic (f-strings, comprehensions)
- ‚úÖ Valida type hints y documentaci√≥n

**QU√â HACES T√ö**:
- ‚úÖ REVISA cada sugerencia cr√≠ticamente
- ‚úÖ APLICA solo mejoras que entiendes
- ‚úÖ EJECUTA tests despu√©s de cada cambio

---

### Fase 3: REFACTOR (Arquitectura) ‚Üí Clean Architecture Enforcer

**Cu√°ndo usarlo**: Cuando hayas completado la feature y quieras validar dise√±o.

**C√≥mo usarlo**:

```markdown
Prompt al Clean Architecture Enforcer:

Rol: Clean Architecture Enforcer
Contexto: CLI de tareas con prioridades. ¬øSigue SRP?

C√≥digo completo:
[pega tareas.py]

Objetivo: Valida si funciones tienen responsabilidad √∫nica.
- ¬øAlguna funci√≥n hace demasiadas cosas?
- ¬øMezclo concerns (IO + l√≥gica de negocio)?
```

**Qu√© hace el agente**:
- ‚úÖ Valida Single Responsibility Principle
- ‚úÖ Detecta "god functions" (funciones que hacen demasiado)
- ‚úÖ Sugiere refactorings si es necesario

**QU√â HACES T√ö**:
- ‚úÖ EVAL√öA si los refactorings son necesarios (no siempre lo son)
- ‚úÖ REFACTORIZA con tests pasando como red de seguridad
- ‚úÖ DOCUMENTA las decisiones arquitect√≥nicas

---

### Fase 4: COVERAGE (Validaci√≥n Final) ‚Üí Test Coverage Strategist

**Cu√°ndo usarlo**: Antes del Pull Request, para validar coverage.

**C√≥mo usarlo**:

```bash
# Ejecuta coverage
pytest --cov=. --cov-report=term-missing
```

```markdown
Prompt al Test Coverage Strategist:

Rol: Test Coverage Strategist
Contexto: Estoy en X% coverage, objetivo 90%+.

Coverage report:
[pega output de pytest --cov]

C√≥digo: tareas.py

Objetivo: Plan priorizado de tests para 90%+.
```

**Qu√© hace el agente**:
- ‚úÖ Identifica l√≠neas sin cubrir
- ‚úÖ Explica POR QU√â son importantes
- ‚úÖ Sugiere tests espec√≠ficos

**QU√â HACES T√ö**:
- ‚úÖ ESCRIBES los tests sugeridos
- ‚úÖ VALIDAS que coverage sube
- ‚úÖ VERIFICAS que tests son significativos (no "test por test")

---

## üìù Documentaci√≥n del Uso de IA (OBLIGATORIO)

Parte del proyecto es **documentar qu√© hiciste con IA y qu√© hiciste manualmente**. Esto es cr√≠tico para:

1. **Transparencia**: Saber qu√© aprendiste vs qu√© delegaste
2. **Auditor√≠a**: Demostrar que entiendes el c√≥digo
3. **Aprendizaje**: Reflexionar sobre el proceso

### Plantilla: `ai_workflow_log.md`

Crea este archivo en tu proyecto y compl√©talo:

```markdown
# AI Workflow Log - Proyecto Final M√≥dulo 1

**Estudiante**: [Tu nombre]
**Fecha**: [Fecha de inicio - Fecha fin]
**Feature**: Sistema de prioridades en tareas

---

## ü§ñ Uso de Agentes IA

### Test Coverage Strategist

**Cu√°ndo us√©**: Fase RED (dise√±o de tests)

**Prompt usado**:
\```
Rol: Test Coverage Strategist
Feature nueva: Sistema de prioridades...
[pega prompt completo]
\```

**Qu√© sugiri√≥ el agente**:
- Test 1: Agregar con prioridad expl√≠cita "alta"
- Test 2: Agregar sin prioridad (default "media")
- Test 3: Prioridad inv√°lida usa "media"
- Test 4: Filtrar por prioridad "alta"
- Test 5: Backward compatibility

**Qu√© casos NO se me hab√≠an ocurrido**:
- ‚ùå Backward compatibility (tareas antiguas sin prioridad)
- ‚ùå Case-insensitive ("ALTA" ‚Üí "alta")

**Qu√© hice yo manualmente**:
- ‚úÖ Escrib√≠ TODOS los tests yo mismo (no copi√© c√≥digo del agente)
- ‚úÖ Entend√≠ por qu√© cada test era necesario
- ‚úÖ A√±ad√≠ un test extra que el agente no sugiri√≥: [descripci√≥n]

---

### Python Best Practices Coach

**Cu√°ndo us√©**: Fase GREEN (refactoring de implementaci√≥n)

**Qu√© sugiri√≥**:
- Usar `Literal["alta", "media", "baja"]` en vez de `str`
- Extraer validaci√≥n a funci√≥n `_normalizar_prioridad()`
- Usar f-strings en mensajes de error

**Qu√© cambios apliqu√©**:
- ‚úÖ Type hints con Literal (entend√≠ que mejora autocomplete)
- ‚úÖ Funci√≥n helper `_normalizar_prioridad()` (separaci√≥n de concerns)
- ‚ùå NO us√© f-strings porque [raz√≥n]

**Tests despu√©s de refactor**: ‚úÖ Todos pasando

---

### Clean Architecture Enforcer

**Cu√°ndo us√©**: Fase REFACTOR (validaci√≥n arquitect√≥nica)

**Violaciones detectadas**:
- [Ninguna / Descripci√≥n de violaci√≥n]

**Refactorings aplicados**:
- [Descripci√≥n de cambios]

---

## ‚úçÔ∏è C√≥digo Escrito Manualmente vs IA

### Escritura Manual (sin asistencia IA)

- ‚úÖ **Todos los tests**: Escrib√≠ cada `assert`, cada caso
- ‚úÖ **Estructura del programa**: Decid√≠ funciones, flujo
- ‚úÖ **Validaciones de negocio**: Reglas de prioridades

### Con Asistencia IA (prompt ‚Üí revisar ‚Üí modificar)

- ü§ñ **Implementaci√≥n inicial de `agregar_tarea`**: IA gener√≥ esqueleto, yo ajust√©
- ü§ñ **List comprehension para filtrado**: IA sugiri√≥, yo entend√≠ y adapt√©
- ü§ñ **Type hints espec√≠ficos**: IA sugiri√≥ `Literal`, yo investigu√© y apliqu√©

### C√≥digo Copiado Directamente de IA (‚ùå EVITAR)

- ‚ùå **Ninguno**: No copi√© c√≥digo sin entender

---

## üéì Aprendizajes

### Conceptos Nuevos Aprendidos

1. **TDD con IA**: La IA sugiere QU√â testear, yo escribo C√ìMO
2. **Type hints avanzados**: `Literal` para strings con valores espec√≠ficos
3. **Coverage estrat√©gico**: No se trata del %, sino de tests significativos
4. **SRP en pr√°ctica**: Funciones peque√±as, una responsabilidad

### Errores Cometidos y Corregidos

1. **Error**: Copi√© c√≥digo de IA sin entender list comprehension
   - **Correcci√≥n**: Pregunt√© a IA "explica esta l√≠nea", luego reescrib√≠ yo
2. **Error**: Alcanc√© 90% con tests in√∫tiles (test por test)
   - **Correcci√≥n**: Elimin√© tests duplicados, us√© parametrizaci√≥n

### Decisiones de Dise√±o (Justificadas)

1. **Por qu√© `prioridad` tiene default "media"**:
   - Backward compatibility con c√≥digo existente
   - No romper tests antiguos

2. **Por qu√© extraje `_normalizar_prioridad()`**:
   - Reutilizable en m√∫ltiples funciones
   - Testeable independientemente
   - Sigue SRP

---

## ‚úÖ Coverage Final

**Coverage alcanzado**: 92%

**L√≠neas sin cubrir (y por qu√©)**:
- L√≠nea X: [Raz√≥n]

**Tests escritos**: 12 tests
- 8 tests cr√≠ticos (alta prioridad)
- 3 tests edge cases (media prioridad)
- 1 test parametrizado (baja, media, alta)

---

## üöÄ Siguientes Pasos

**Si tuviera m√°s tiempo, mejorar√≠a**:
- [ ] A√±adir validaci√≥n de longitud de `nombre`
- [ ] Implementar `eliminar_tarea()`
- [ ] Persistencia en JSON (ahora solo memoria)

**Lo que aplicar√© en el pr√≥ximo m√≥dulo**:
- Workflow RED-GREEN-REFACTOR siempre
- Validar con agentes DESPU√âS de escribir, no antes
- Documentar uso de IA en cada fase
```

---

## üîç Validaci√≥n de C√≥digo Generado por IA

**REGLA DE ORO**: NUNCA conf√≠es ciegamente en c√≥digo de IA. Siempre valida.

### Checklist de Validaci√≥n (ANTES de aceptar c√≥digo de IA)

#### 1. ¬øEntiendes cada l√≠nea?

```python
# ‚ùå C√≥digo de IA que NO entiendes
return [t for t in todas if t.get("prioridad") == prioridad]

# ‚úÖ ANTES de aceptar, pregunta:
"Explica esta l√≠nea paso a paso. ¬øQu√© hace .get()? ¬øPor qu√© no usar t['prioridad']?"
```

**Acci√≥n**: Si no entiendes algo, pregunta a la IA "Explica como si tuviera 10 a√±os".

---

#### 2. ¬øLos tests pasan?

```bash
# Ejecuta tests DESPU√âS de pegar c√≥digo de IA
pytest -v

# ‚ùå Si fallan: NO aceptes el c√≥digo, investiga por qu√©
# ‚úÖ Si pasan: Bien, pero NO es suficiente
```

**Acci√≥n**: Tests pasando es m√≠nimo, no garant√≠a de calidad.

---

#### 3. ¬øSigue las convenciones del proyecto?

**Checklist**:
- [ ] Type hints en todos los par√°metros
- [ ] Nombres largos y descriptivos (no `p`, `t`, `x`)
- [ ] Docstrings en funciones p√∫blicas
- [ ] Sin c√≥digo "m√°gico" (n√∫meros sin constantes, strings hardcodeados)

```python
# ‚ùå C√≥digo de IA que viola convenciones
def a(p):
    if p not in ["alta", "media", "baja"]:  # String hardcodeado
        return "media"
    return p

# ‚úÖ Tu versi√≥n corregida
PRIORIDADES = ("alta", "media", "baja")

def _normalizar_prioridad(prioridad: str) -> str:
    """Normaliza prioridad o usa 'media' si inv√°lida."""
    return prioridad if prioridad in PRIORIDADES else "media"
```

---

#### 4. ¬øEs el c√≥digo M√çNIMO necesario?

La IA tiende a sobre-complicar. Valida:

```python
# ‚ùå IA a√±ade complejidad innecesaria
def agregar_tarea(ruta, nombre, prioridad="media"):
    try:
        with open(ruta, "r") as f:
            tareas = json.load(f)
    except FileNotFoundError:
        tareas = []
    except Exception as e:
        logger.error(f"Error: {e}")
        tareas = []
    # ... 20 l√≠neas m√°s

# ‚úÖ Versi√≥n m√°s simple (si ya tienes cargar_tareas())
def agregar_tarea(ruta, nombre, prioridad="media"):
    tareas = cargar_tareas(ruta)  # Reutilizar funci√≥n existente
    nueva = {"id": nuevo_id(tareas), "nombre": nombre, "prioridad": prioridad}
    tareas.append(nueva)
    guardar_tareas(ruta, tareas)
    return nueva
```

**Pregunta cr√≠tica**: ¬øHay funciones existentes que puedo reutilizar?

---

#### 5. ¬øFunciona con edge cases?

**Tests obligatorios DESPU√âS de c√≥digo IA**:

```python
# Test edge case: Prioridad vac√≠a
def test_prioridad_vacia():
    tarea = agregar_tarea(tmp, "Test", prioridad="")
    assert tarea["prioridad"] == "media"  # ¬øPasa?

# Test edge case: Prioridad con espacios
def test_prioridad_con_espacios():
    tarea = agregar_tarea(tmp, "Test", prioridad="  alta  ")
    assert tarea["prioridad"] == "alta"  # ¬øPasa o falla?

# Test edge case: Case-insensitive
def test_prioridad_mayusculas():
    tarea = agregar_tarea(tmp, "Test", prioridad="ALTA")
    assert tarea["prioridad"] == "alta"
```

**Si alg√∫n test falla**: El c√≥digo de IA tiene bugs. Arr√©glalo ANTES de continuar.

---

#### 6. ¬øIntroduce deuda t√©cnica?

**Red flags**:
- ‚ùå TODO comments: `# TODO: fix this later`
- ‚ùå Warnings de linter: `ruff check` reporta issues
- ‚ùå Duplicaci√≥n: C√≥digo copiado en m√∫ltiples lugares
- ‚ùå Acoplamiento: Funci√≥n depende de detalles de implementaci√≥n

**Acci√≥n**: Ejecuta linter y corrige ANTES de commit.

```bash
ruff check tareas.py
# Si hay warnings, arregla o justifica por qu√© no
```

---

### Workflow de Validaci√≥n (Paso a Paso)

Cuando la IA te genera c√≥digo, sigue este proceso:

```markdown
1. [ ] Leo el c√≥digo l√≠nea por l√≠nea
   - Si no entiendo algo ‚Üí Pregunto "Explica X"
   - Si hay c√≥digo "m√°gico" ‚Üí Pido versi√≥n m√°s simple

2. [ ] Copio el c√≥digo a mi archivo
   - NO directamente, escribo yo tecleando (refuerza aprendizaje)

3. [ ] Ejecuto tests
   - pytest -v
   - ¬øTodos pasan? ‚Üí Contin√∫a
   - ¬øAlguno falla? ‚Üí Investiga, NO copies m√°s c√≥digo

4. [ ] A√±ado tests de edge cases
   - Casos que IA no consider√≥
   - Si fallan ‚Üí Arreglo el c√≥digo

5. [ ] Reviso con linter
   - ruff check
   - Corrijo warnings

6. [ ] Pregunto a Clean Architecture Enforcer
   - ¬øSigue SRP?
   - ¬øIntroduce acoplamiento?

7. [ ] Documento en ai_workflow_log.md
   - Qu√© gener√≥ IA
   - Qu√© modifiqu√© yo
   - Por qu√©

8. [ ] Commit con mensaje descriptivo
   - feat: a√±adir prioridades con validaci√≥n
   - (NO: "c√≥digo de IA" o "cambios varios")
```

---

## üéØ Criterios de √âxito del Proyecto Final

Has completado el Proyecto Final del M√≥dulo 1 si:

### T√©cnico
- [ ] Coverage 90%+ con tests significativos
- [ ] Todos los tests pasan (pytest -v)
- [ ] Sin warnings de linter (ruff check)
- [ ] Feature de prioridades implementada completa
- [ ] Backward compatibility mantenida

### Metodolog√≠a
- [ ] Usaste TDD: RED ‚Üí GREEN ‚Üí REFACTOR
- [ ] Aplicaste SRP (validado por Clean Architecture Enforcer)
- [ ] Git workflow: Branch ‚Üí Commits ‚Üí PR
- [ ] Tests escritos ANTES de implementaci√≥n

### IA Workflow
- [ ] Usaste Test Coverage Strategist (fase RED)
- [ ] Usaste Python Best Practices Coach (fase REFACTOR)
- [ ] Usaste Clean Architecture Enforcer (validaci√≥n)
- [ ] Documentaste en `ai_workflow_log.md` qu√© hizo IA y qu√© hiciste t√∫

### Comprensi√≥n
- [ ] Puedes explicar cada l√≠nea de c√≥digo
- [ ] Entiendes POR QU√â cada test es necesario
- [ ] Sabes cu√°ndo es OK usar IA y cu√°ndo no
- [ ] Reflexionaste en el log sobre aprendizajes

---

## üö´ Antipatrones a Evitar

### ‚ùå Copiar c√≥digo de IA sin entender

**Se√±al de problema**:
```python
# C√≥digo que pegaste pero no entiendes
return [t for t in todas if t.get("prioridad") == prioridad]
```

**Pregunta clave**: "Si tuviera que explicar esta l√≠nea a alguien, ¬øpodr√≠a hacerlo?"

**Soluci√≥n**: Pregunta "Explica X paso a paso" ANTES de aceptar el c√≥digo.

---

### ‚ùå Alcanzar 90% con tests in√∫tiles

**Se√±al de problema**:
```python
def test_1():
    assert True  # Test que siempre pasa

def test_nombre_no_es_numero():
    tarea = agregar_tarea(tmp, "Test")
    assert isinstance(tarea["nombre"], str)  # Test trivial
```

**Soluci√≥n**: Pregunta "¬øEste test falla si hay un bug real?" Si no, b√≥rralo.

---

### ‚ùå Usar IA para TODO

**Se√±al de problema**: `ai_workflow_log.md` dice "IA gener√≥ todo, yo solo ejecut√©".

**Soluci√≥n**:
- T√ö escribes tests
- T√ö dise√±as arquitectura
- IA solo sugiere mejoras

---

### ‚ùå No validar c√≥digo de IA

**Se√±al de problema**: Pegaste c√≥digo, tests pasan, hiciste commit inmediato.

**Soluci√≥n**: Sigue el Workflow de Validaci√≥n completo (checklist de 8 pasos).

---

## üìö Recursos de Apoyo

### Agentes Educativos

- **Test Coverage Strategist**: `.claude/agents/educational/test-coverage-strategist.md`
- **Python Best Practices Coach**: `.claude/agents/educational/python-best-practices-coach.md`
- **Clean Architecture Enforcer**: `.claude/agents/educational/clean-architecture-enforcer.md`

### Documentaci√≥n

- **Ejercicio completo**: `ejercicio_clase4_ai_avanzado.md` (en esta carpeta)
- **Glosario**: `Glosario - Clase 4.md` (t√©rminos clave)

### Comandos √ötiles

```bash
# Tests
pytest -v                                    # Ejecutar todos los tests
pytest --cov=. --cov-report=term-missing    # Coverage detallado
pytest -k "prioridad"                        # Solo tests de prioridad

# Linting
ruff check tareas.py                         # Verificar estilo
ruff check --fix tareas.py                   # Auto-corregir

# Git
git status                                   # Ver cambios
git diff                                     # Ver diferencias
git add tareas.py test_*.py                 # A√±adir archivos
git commit -m "feat: a√±adir prioridades"    # Commit
```

---

## üéì Reflexi√≥n Final

Este proyecto final NO es sobre "hacer funcionar el c√≥digo". Es sobre:

1. **Metodolog√≠a**: TDD, Git workflow, uso estrat√©gico de IA
2. **Criterio**: Saber CU√ÅNDO usar IA, CU√ÅNDO escribir t√∫
3. **Comprensi√≥n**: Entender cada l√≠nea, no copiar ciegamente
4. **Documentaci√≥n**: Transparencia sobre qu√© aprendiste

**Pregunta clave para tu reflexi√≥n**:

> "Si tuviera que explicar este c√≥digo a un compa√±ero SIN mencionar que us√© IA, ¬øpodr√≠a hacerlo con confianza?"

Si la respuesta es S√ç ‚Üí Has completado el proyecto exitosamente.

Si la respuesta es NO ‚Üí Revisa, pregunta, entiende. Repite hasta que S√ç.

---

**Pr√≥ximo paso**: M√≥dulo 2 - Arquitectura Limpia con FastAPI + Agentes Especializados üöÄ