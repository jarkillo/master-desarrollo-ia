# Ejercicios Pr√°cticos: Repository Pattern y Clean Architecture con IA

## üéØ Objetivo

Dominar el uso de IA para **dise√±ar, implementar y validar arquitectura limpia** aplicando Repository Pattern, Open/Closed Principle y Dependency Inversion.

Al completar estos ejercicios, sabr√°s:
- ‚úÖ Generar Protocols con IA que cumplen SOLID
- ‚úÖ Implementar repositorios concretos (SQLite, Redis)
- ‚úÖ Validar arquitectura con agentes educacionales
- ‚úÖ Detectar y corregir violaciones de DIP
- ‚úÖ Refactorizar c√≥digo legacy a Clean Architecture

---

## Ejercicio 1: Implementar RepositorioSQLite con IA

### üìã Contexto

Tienes `RepositorioMemoria` y `RepositorioJSON` funcionando. Ahora necesitas persistencia real en base de datos SQLite para escalar a producci√≥n.

**Requisitos**:
- Debe cumplir el mismo Protocol (`RepositorioTareas`)
- Usar `sqlite3` del stdlib (sin ORMs externos)
- Manejo robusto de errores (tabla no existe, BD corrupta)
- IDs autoincrementales (AUTOINCREMENT en SQLite)

---

### ü§ñ Paso 1: Dise√±ar el prompt

**Tu tarea**: Escribe un prompt estructurado para que IA genere `RepositorioSQLite`.

**Plantilla sugerida**:

```
Rol: [¬øQu√© expertise necesitas?]

Contexto:
[Describe el Protocol, el esquema de la tabla, requisitos de la BD]

Objetivo:
[Qu√© clase quieres generar]

Requisitos:
[Lista completa de funcionalidades]

Restricciones:
[L√≠mites t√©cnicos: solo sqlite3, no ORMs, etc.]

Formato:
```python
# api/repositorio_sqlite.py
# C√≥digo aqu√≠
```

Explica:
[Qu√© decisiones de dise√±o quieres que justifique]
```

**Criterios de √©xito**:
- [ ] Prompt incluye el Protocol completo como referencia
- [ ] Especifica el esquema de la tabla (CREATE TABLE)
- [ ] Pide manejo de conexiones con context managers
- [ ] Requiere type hints completos
- [ ] Pide docstrings que expliquen manejo de errores

---

### üî® Paso 2: Generar el c√≥digo con IA

Ejecuta tu prompt con Claude/ChatGPT/Copilot.

**Validaci√≥n r√°pida**:
```python
# ¬øEl c√≥digo tiene estas caracter√≠sticas?
- [ ] def __init__(self, ruta_bd: str = "tareas.db"): ...
- [ ] _crear_tabla_si_no_existe() en __init__
- [ ] with sqlite3.connect(...) as conn: (context manager)
- [ ] try/except para manejar errores de BD
- [ ] Implementa los 5 m√©todos del Protocol
```

---

### ‚úÖ Paso 3: Validar con Python Best Practices Coach

**Prompt de validaci√≥n**:

```
Rol: Python Best Practices Coach

Revisa este c√≥digo de RepositorioSQLite y valida:

1. ¬øUsa context managers para conexiones? (with conn:)
2. ¬øManeja excepciones de BD? (sqlite3.Error)
3. ¬øUsa SQL parametrizado? (? placeholders, NO f-strings)
4. ¬øCierra conexiones correctamente?
5. ¬øLos type hints son correctos?

C√≥digo:
[Pegar RepositorioSQLite completo]

Formato:
‚úÖ Validaciones correctas
‚ùå Problemas encontrados (con l√≠nea y correcci√≥n)
```

**Red flags comunes**:

```python
# ‚ùå SQL Injection vulnerable
cursor.execute(f"SELECT * FROM tareas WHERE id = {id}")  # MAL

# ‚úÖ SQL parametrizado (seguro)
cursor.execute("SELECT * FROM tareas WHERE id = ?", (id,))  # BIEN


# ‚ùå Conexi√≥n no se cierra
conn = sqlite3.connect("tareas.db")
cursor = conn.cursor()  # MAL: si hay excepci√≥n, no se cierra

# ‚úÖ Context manager cierra autom√°ticamente
with sqlite3.connect("tareas.db") as conn:
    cursor = conn.cursor()  # BIEN: se cierra incluso con excepciones
```

---

### üß™ Paso 4: Agregar a los tests parametrizados

**Tu tarea**: Modifica `test_repositorios_integracion.py` para incluir SQLite.

**Cambio necesario**:

```python
# tests_integrations/test_repositorios_integracion.py

from api.repositorio_sqlite import RepositorioSQLite  # NUEVO

@pytest.fixture(params=["memoria", "json", "sqlite"])  # Agregar "sqlite"
def repositorio(request, tmp_path):
    if request.param == "memoria":
        return RepositorioMemoria()
    elif request.param == "json":
        archivo = tmp_path / f"tareas_{request.node.name}.json"
        return RepositorioJSON(str(archivo))
    elif request.param == "sqlite":  # NUEVO
        bd = tmp_path / f"tareas_{request.node.name}.db"
        return RepositorioSQLite(str(bd))
```

**Ejecutar tests**:

```bash
cd "Modulo 2 ‚Äì Ingenier√≠a y Arquitectura/Clase 4 - Open_Closed y Dependency Inversion"
pytest tests_integrations/ -v
```

**Criterios de √©xito**:
- [ ] Los 15 tests pasan para los **3 repositorios** (45 tests totales)
- [ ] Si alg√∫n test falla solo para SQLite, hay un bug de implementaci√≥n
- [ ] Todos los repositorios son **perfectamente intercambiables**

---

### üíæ Entregable

**Archivo a crear**: `api/repositorio_sqlite.py` (aproximadamente 150 l√≠neas)

**Incluir en el c√≥digo**:
- Docstring de clase con caracter√≠sticas y limitaciones
- M√©todo `_crear_tabla_si_no_existe()` privado
- Context managers en todos los m√©todos
- Try/except con sqlite3.Error
- Type hints completos
- Comentarios que expliquen SQL no obvio

**Extra (opcional)**:
- √çndice en la columna `id` para b√∫squedas r√°pidas
- Manejo de concurrent access (BEGIN TRANSACTION)
- Logging de errores con `logging` module

---

## Ejercicio 2: Code Review de Arquitectura con Agentes Educacionales

### üìã Contexto

Te uniste a un proyecto donde el c√≥digo viola principios SOLID. Tu tarea: usar agentes de IA para identificar violaciones y proponer refactorizaciones.

---

### üîç Paso 1: Analizar c√≥digo legacy

**C√≥digo problem√°tico** (simula un proyecto real):

```python
# api/api_legacy.py (C√ìDIGO MALO - NO USAR)
from fastapi import FastAPI
import json

app = FastAPI()

@app.post("/tareas")
def crear_tarea(nombre: str):
    # PROBLEMA 1: L√≥gica de persistencia en la API
    with open("tareas.json", "r") as f:
        tareas = json.load(f)

    # PROBLEMA 2: Generaci√≥n de ID en la API
    nuevo_id = max([t["id"] for t in tareas], default=0) + 1

    # PROBLEMA 3: L√≥gica de negocio mezclada
    nueva_tarea = {
        "id": nuevo_id,
        "nombre": nombre,
        "completada": False
    }
    tareas.append(nueva_tarea)

    # PROBLEMA 4: Escritura en disco directamente
    with open("tareas.json", "w") as f:
        json.dump(tareas, f)

    return nueva_tarea


@app.get("/tareas")
def listar_tareas():
    # PROBLEMA 5: C√≥digo duplicado (lectura de archivo)
    with open("tareas.json", "r") as f:
        return json.load(f)
```

**Tu tarea**: Usa agentes de IA para identificar TODAS las violaciones de SOLID.

---

### ü§ñ Paso 2: Validar con FastAPI Design Coach

**Prompt**:

```
Rol: FastAPI Design Coach experto en Clean Architecture

Contexto:
Analiza este c√≥digo de una API FastAPI

C√≥digo:
[Pegar api_legacy.py completo]

Objetivo:
Identifica TODAS las violaciones de:
1. Single Responsibility Principle (SRP)
2. Open/Closed Principle (OCP)
3. Dependency Inversion Principle (DIP)
4. Separation of Concerns (API vs Servicio vs Repositorio)

Para cada violaci√≥n:
- Indica la l√≠nea exacta
- Explica QU√â principio se viola y POR QU√â
- Prop√≥n la refactorizaci√≥n correcta
- Muestra c√≥digo antes/despu√©s

Formato:
## ‚ùå Violaciones encontradas
### Violaci√≥n 1: [Nombre del principio]
**L√≠nea**: X
**Problema**: [Explicaci√≥n]
**Refactorizaci√≥n**: [C√≥digo correcto]
```

**Resultado esperado** (parcial):

```markdown
## ‚ùå Violaciones encontradas

### Violaci√≥n 1: Dependency Inversion Principle (DIP)
**L√≠nea**: 8-10
**Problema**: La API depende directamente del detalle de implementaci√≥n (archivo JSON).
Cambiar de JSON a SQLite requiere modificar TODOS los endpoints.

**Refactorizaci√≥n**:
```python
# ‚úÖ CORRECTO: Inyectar repositorio abstracto
from api.repositorio_base import RepositorioTareas

def crear_tarea(
    nombre: str,
    servicio: ServicioTareas = Depends(obtener_servicio)  # Inyecci√≥n
):
    tarea = servicio.crear(nombre)
    return tarea.model_dump()
```

### Violaci√≥n 2: Single Responsibility Principle (SRP)
**L√≠nea**: Toda la funci√≥n `crear_tarea`
**Problema**: El endpoint hace 4 cosas:
1. Lee archivo (persistencia)
2. Genera ID (l√≥gica de dominio)
3. Crea tarea (l√≥gica de negocio)
4. Escribe archivo (persistencia)

**Refactorizaci√≥n**: Separar en capas (API ‚Üí Servicio ‚Üí Repositorio)
```

---

### üîß Paso 3: Refactorizar a Clean Architecture

**Tu tarea**: Usando las recomendaciones de IA, refactoriza el c√≥digo legacy en 3 capas:

1. **Crear `repositorio_base.py`** (Protocol)
2. **Crear `servicio_tareas.py`** (L√≥gica de negocio)
3. **Refactorizar `api.py`** (Solo endpoints)

**Criterios de validaci√≥n**:

```python
# Pregunta clave 1: ¬øPuedes cambiar de JSON a SQLite cambiando 1 sola l√≠nea?
# Si NO ‚Üí arquitectura incorrecta

# Pregunta clave 2: ¬øEl servicio importa RepositorioJSON o RepositorioSQLite?
# Si S√ç ‚Üí violaci√≥n de DIP

# Pregunta clave 3: ¬øLa API tiene l√≥gica de negocio (if, c√°lculos, validaciones)?
# Si S√ç ‚Üí violaci√≥n de SRP
```

---

### üíæ Entregable

**Archivos a entregar**:
1. `repositorio_base.py` - Protocol con contrato
2. `repositorio_json_refactorizado.py` - Implementaci√≥n concreta
3. `servicio_tareas_refactorizado.py` - L√≥gica de negocio
4. `api_refactorizado.py` - Solo endpoints

**Documento de refactorizaci√≥n**:

Crea `REFACTORING_NOTES.md` con:
- Lista de violaciones encontradas (con agente usado)
- Decisiones de dise√±o tomadas
- Antes/despu√©s de cada cambio clave
- Lecciones aprendidas

**Validaci√≥n final**:

Ejecuta este prompt para confirmar que la refactorizaci√≥n es correcta:

```
Rol: Clean Architecture Enforcer

Valida que esta arquitectura refactorizada cumple SOLID:

Archivos:
[Pegar los 4 archivos]

Checklist:
1. ¬øHay un Protocol abstracto?
2. ¬øEl servicio depende solo del Protocol?
3. ¬øLa API solo llama al servicio?
4. ¬øCada capa tiene una sola responsabilidad?
5. ¬øSe puede cambiar de repositorio con 1 l√≠nea?

Responde S√ç/NO para cada punto y justifica.
```

---

## Ejercicio 3: Implementar Caching con Decorator Pattern

### üìã Contexto

Tu `RepositorioJSON` funciona, pero es lento (lee el archivo completo en cada operaci√≥n). Quieres agregar cache **sin modificar** la implementaci√≥n original.

**Objetivo**: Implementar un `RepositorioCache` que envuelve otro repositorio y cachea resultados.

---

### üèóÔ∏è Paso 1: Dise√±ar el Decorator Pattern con IA

**Prompt**:

```
Rol: Arquitecto Python experto en patrones de dise√±o

Contexto:
Tengo un RepositorioTareas (Protocol con m√©todos: guardar, listar, obtener_por_id, eliminar, completar).
Quiero agregar cache en memoria para mejorar performance SIN modificar las implementaciones existentes.

Objetivo:
Dise√±a un RepositorioCache que:
- Implementa el mismo Protocol (es transparente)
- Envuelve otro repositorio (Decorator Pattern)
- Cachea resultados de listar() y obtener_por_id()
- Invalida cache cuando se modifica (guardar, eliminar, completar)

Requisitos:
- Debe cumplir el Protocol RepositorioTareas
- Constructor: __init__(self, repositorio_interno: RepositorioTareas)
- Cache simple: dict de Python (no Redis para este ejercicio)
- Docstrings que expliquen la estrategia de invalidaci√≥n

Restricciones:
- NO modificar RepositorioMemoria, RepositorioJSON, RepositorioSQLite
- El servicio NO debe saber que hay cache (transparencia)

Formato:
```python
# api/repositorio_cache.py
# C√≥digo con explicaci√≥n de cada decisi√≥n
```

Explica:
- Por qu√© Decorator Pattern es apropiado aqu√≠
- Cu√°ndo invalidar el cache (qu√© m√©todos)
- Limitaciones del cache simple (vs Redis)
```

---

### üî® Paso 2: Implementar y validar

**C√≥digo esperado** (esqueleto):

```python
# api/repositorio_cache.py
from typing import List, Optional, Dict
from api.repositorio_base import RepositorioTareas
from api.servicio_tareas import Tarea


class RepositorioCache:
    """Decorador que agrega cache a cualquier repositorio.

    Estrategia de cache:
    - listar(): cachea la lista completa
    - obtener_por_id(): cachea cada tarea por ID
    - guardar/eliminar/completar: invalidan cache completo

    Limitaciones:
    - Cache en memoria (se pierde al reiniciar)
    - No es thread-safe (solo para single-threaded apps)
    - Invalida TODO el cache en modificaciones (puede optimizarse)
    """

    def __init__(self, repositorio_interno: RepositorioTareas):
        self._repo = repositorio_interno
        self._cache_lista: Optional[List[Tarea]] = None
        self._cache_por_id: Dict[int, Tarea] = {}

    def _invalidar_cache(self) -> None:
        """Limpia todo el cache."""
        self._cache_lista = None
        self._cache_por_id.clear()

    def guardar(self, tarea: Tarea) -> None:
        self._repo.guardar(tarea)
        self._invalidar_cache()  # Modificaci√≥n ‚Üí invalidar

    def listar(self) -> List[Tarea]:
        if self._cache_lista is None:
            # Cache miss ‚Üí cargar del repositorio interno
            self._cache_lista = self._repo.listar()
        return self._cache_lista.copy()  # Copia defensiva

    def obtener_por_id(self, id: int) -> Optional[Tarea]:
        if id not in self._cache_por_id:
            # Cache miss ‚Üí cargar del repositorio interno
            tarea = self._repo.obtener_por_id(id)
            if tarea:
                self._cache_por_id[id] = tarea
        return self._cache_por_id.get(id)

    # TODO: Implementa eliminar y completar con invalidaci√≥n
```

**Tu tarea**: Completa los m√©todos `eliminar` y `completar`.

---

### ‚úÖ Paso 3: Validar transparencia (cumple Protocol)

**Test de intercambiabilidad**:

```python
# tests_integrations/test_repositorio_cache.py
import pytest
from api.repositorio_memoria import RepositorioMemoria
from api.repositorio_cache import RepositorioCache
from api.servicio_tareas import Tarea


def test_cache_es_transparente():
    """Valida que RepositorioCache cumple el mismo Protocol."""
    repo_base = RepositorioMemoria()
    repo_con_cache = RepositorioCache(repo_base)

    # Guardar a trav√©s del cache
    tarea = Tarea(id=0, nombre="Test", completada=False)
    repo_con_cache.guardar(tarea)

    # Listar desde el cache
    tareas = repo_con_cache.listar()
    assert len(tareas) == 1
    assert tareas[0].nombre == "Test"


def test_cache_mejora_performance():
    """Valida que el cache reduce accesos al repositorio interno."""
    repo_base = RepositorioMemoria()
    repo_con_cache = RepositorioCache(repo_base)

    # Guardar tarea
    tarea = Tarea(id=0, nombre="Cacheable", completada=False)
    repo_con_cache.guardar(tarea)

    # Primera llamada: cache miss
    tareas1 = repo_con_cache.listar()

    # Segunda llamada: cache hit (deber√≠a ser la misma lista cacheada)
    tareas2 = repo_con_cache.listar()

    # Verificar que el cache funciona (mismo contenido, no mismo objeto)
    assert tareas1 == tareas2
    assert tareas1 is not tareas2  # Copia defensiva
```

---

### üöÄ Paso 4: Usar el cache en la aplicaci√≥n

**Modificar `api/dependencias.py`** (solo cambiar 1 l√≠nea):

```python
# ANTES (sin cache)
def obtener_servicio():
    repo = RepositorioJSON("tareas.json")
    return ServicioTareas(repo)

# DESPU√âS (con cache)
from api.repositorio_cache import RepositorioCache

def obtener_servicio():
    repo_base = RepositorioJSON("tareas.json")
    repo_con_cache = RepositorioCache(repo_base)  # Decorador
    return ServicioTareas(repo_con_cache)
```

**Pregunta clave**: ¬øTuviste que modificar `ServicioTareas` o `api.py`?

- ‚úÖ **NO** ‚Üí Decorator Pattern correcto (Open/Closed cumplido)
- ‚ùå **S√ç** ‚Üí Violaci√≥n de OCP, revisar dise√±o

---

### üíæ Entregable

**Archivos a crear**:
1. `api/repositorio_cache.py` (~100 l√≠neas)
2. `tests_integrations/test_repositorio_cache.py` (~150 l√≠neas)

**Documento de an√°lisis**:

Crea `CACHE_DESIGN.md` con:

```markdown
# Dise√±o de Cache con Decorator Pattern

## Decisiones de dise√±o

### ¬øPor qu√© Decorator Pattern?
[Explica por qu√© envolver en vez de modificar]

### Estrategia de invalidaci√≥n
[Cu√°ndo invalidar el cache y por qu√©]

### Limitaciones
[Qu√© NO hace este cache (thread-safety, TTL, LRU)]

## Performance

### Benchmark simple
```python
import time

repo_sin_cache = RepositorioJSON("tareas.json")
repo_con_cache = RepositorioCache(repo_sin_cache)

# Medir 100 lecturas sin cache
start = time.time()
for _ in range(100):
    repo_sin_cache.listar()
sin_cache_time = time.time() - start

# Medir 100 lecturas con cache
start = time.time()
for _ in range(100):
    repo_con_cache.listar()
con_cache_time = time.time() - start

print(f"Mejora: {sin_cache_time / con_cache_time:.2f}x m√°s r√°pido")
```

### Mejoras futuras
- [ ] LRU cache (limitar tama√±o)
- [ ] TTL (time-to-live)
- [ ] Invalidaci√≥n selectiva (solo IDs modificados)
- [ ] Redis para cache distribuido
```

---

## üèÜ Criterios de √âxito General

Para considerar los 3 ejercicios completos, debes poder responder **S√ç** a todas estas preguntas:

### Ejercicio 1 (RepositorioSQLite)
- [ ] ¬øLos 15 tests pasan para los 3 repositorios (Memoria, JSON, SQLite)?
- [ ] ¬øUsas SQL parametrizado (no f-strings)?
- [ ] ¬øUsas context managers para conexiones?
- [ ] ¬øPuedes cambiar de JSON a SQLite cambiando 1 l√≠nea?

### Ejercicio 2 (Refactorizaci√≥n)
- [ ] ¬øIdentificaste al menos 5 violaciones de SOLID en el c√≥digo legacy?
- [ ] ¬øTu arquitectura refactorizada cumple Clean Architecture?
- [ ] ¬øEl servicio depende del Protocol, NO de clases concretas?
- [ ] ¬øCada capa tiene una sola responsabilidad?

### Ejercicio 3 (Cache)
- [ ] ¬øEl cache es transparente (cumple el Protocol)?
- [ ] ¬øNO modificaste ServicioTareas ni api.py para agregar cache?
- [ ] ¬øEl cache invalida correctamente en modificaciones?
- [ ] ¬øMediste la mejora de performance (ej: 10x m√°s r√°pido)?

---

## üìö Recursos Adicionales

**Agentes educacionales recomendados**:
- `.claude/agents/educational/python-best-practices-coach.md` ‚Üí Valida Protocols, type hints
- `.claude/agents/educational/fastapi-design-coach.md` ‚Üí Revisa separaci√≥n de capas
- `.claude/agents/educational/database-orm-specialist.md` ‚Üí Valida SQL y manejo de BD

**Patrones de dise√±o**:
- Repository Pattern: https://martinfowler.com/eaaCatalog/repository.html
- Decorator Pattern: https://refactoring.guru/design-patterns/decorator/python
- Dependency Injection: https://fastapi.tiangolo.com/tutorial/dependencies/

**Documentaci√≥n Python**:
- PEP 544 (Protocols): https://peps.python.org/pep-0544/
- sqlite3 module: https://docs.python.org/3/library/sqlite3.html
- Context managers: https://docs.python.org/3/reference/datamodel.html#context-managers

---

## üí° Tips para usar IA efectivamente

### Prompts iterativos
No esperes que IA genere c√≥digo perfecto en el primer intento. Itera:

1. **Prompt inicial**: Genera estructura b√°sica
2. **Validar con agente**: Identifica problemas
3. **Prompt de correcci√≥n**: "Corrige [problema espec√≠fico]"
4. **Repetir** hasta que no haya violaciones

### Pregunta "¬øPor qu√©?"
Siempre pide a IA que justifique sus decisiones:

```
¬øPor qu√© usaste X en vez de Y?
¬øQu√© pasar√≠a si cambio Z?
¬øQu√© limitaciones tiene este enfoque?
```

### Valida con m√∫ltiples agentes
Usa diferentes agentes para diferentes aspectos:

- **Python Best Practices Coach**: Sintaxis, type hints, PEP 8
- **FastAPI Design Coach**: Arquitectura, separaci√≥n de capas
- **Database ORM Specialist**: SQL, manejo de BD

Cada agente detecta problemas diferentes ‚Üí cobertura completa.

---

**¬°√âxito con los ejercicios! üöÄ**
